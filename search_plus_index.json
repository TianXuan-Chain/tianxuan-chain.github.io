{"./":{"url":"./","title":"天玄区块链","summary":"天玄链是网易星球区块链团队主导研发、安全可控的企业级金融联盟链底层平台","keywords":"","body":"天玄区块链 天玄链以联盟链的实际需求为出发点，兼顾性能、安全、可运维性、易用性、可扩展性，支持多种 SDK ，并提供了可视化的中间件工具，大幅缩短建链、开发、部署应用的时间。 此外，天玄链通过信通院可信区块链评测功能、性能两项评测，单链 TPS 可达 30w 以上。 关键特性 整体架构 架构模型 双层架构 并行计算 支持块内交易并行执行 节点类型 共识节点 计算模型 排序-执行-验证 系统性能 峰值TPS 30w + 交易确认时延 秒级 硬件推荐配置 CPU 2.4GHz * 32/64核 内存 64GB 存储 4TB 网络带宽 100Mb 账本模型 数据结构 链式结构，区块通过哈希链相连 是否分叉 不分叉 记账类型 账户模型（非 UTXO） 共识算法 共识框架 可插拔设计 共识算法 双层异步 BFT 算法 存储引擎 存储设计 支持 k-v 引擎类型 支持 RocksDB 网络协议 节点间通信 P2P 协议 客户端与节点通信 JsonRPC，Channel 协议 智能合约 合约引擎 支持 Solidity 和预编译合约 引擎特点 图灵完备，沙盒运行 密码算法和协议 国密算法 支持 国密SSL 支持 哈希算法 Keccak256、SM3 对称加密算法 AES、SM4 非对称加密算法 ECDSA、SM2、ED25519 非对称加密椭圆曲线 Secp256k1、Sm2p256v1 安全控制 存储安全 支持落盘数据加密存储 通信安全 支持全流程 SSL 准入安全 基于 PKI 身份认证体系 证书管理 支持证书颁发、撤销、更新 权限控制 支持细粒度权限控制 隐私保护 隐私保护协议 支持群签名、环签名、同态加密 场景化隐私保护机制 基于支持隐匿支付、匿名投票、匿名竞拍、选择性披露等场景 开发支持 开发建链工具 一键搭链脚本 SDK语言 Java 运维支持 运维建链工具 企业级联盟链部署工具 可视化数据展现 区块链浏览器 动态管理节点 支持动态新增、剔除、变更节点 数据备份与恢复 提供数据导出与恢复服务 架构 在非分片架构下，共识网络使用异步流水线 BFT 和完全 N 叉拓扑网络实现每秒 10~30 万的交易序列确认。解决了复杂交易执行耗时长导致的网络抖动以及单节点广播速度慢等问题。而后通过通用 DAG 状态分析器和并行执行引擎对已确序交易进行快速执行。最后再通过 Verfiy_BFT 算法实现共识状态的快速变更。 技术亮点总结如下： 异步流水线 BFT + 完全 N 叉拓扑网络：实现高效稳定的共识算法 (共识算法可插拔组件化) 通用 DAG 状态分析器 + 并行执行引擎：可以使交易执行器最大并行度执行任意交易集合 Assembly-VM：实现支持 Solidity 与 Java 语言的 Evm 和 Jvm 多种加密套件：支持国密套件 (包括 TLS ，签名以及加密等功能) 安全性 考虑到联盟链的高安全性需求，除了节点之间、节点与客户端之间通信采用 TLS 安全协议外，天玄链还实现了一整套安全解决方案： 网络准入机制：限制节点加入、退出联盟链，保障了系统安全性 支持国密算法：支持国密加密、签名算法和国密通信协议 落盘加密方案：支持加密节点落盘数据，保障链上数据的机密性 性能 为提升系统性能，天玄从存储优化，共识效率提升以及交易并发执行这几个方面进行了优化，使得交易处理性能最高达到十万级以上： 状态存储去 MPT 结构，采用 k-v 存储：去除 MPT 结构，使得存储和访问的效率更高 共识与执行分离：将执行从共识流程中抽离，只对交易定序进行共识，使共识过程更加快速稳定 交易并行执行：基于 DAG 算法根据交易间互斥关系构建区块内交易执行流，最大化并行执行区块内的交易。交易生命周期的异步并行处理：共识、同步、落盘等各个环节的异步化以及并行处理 易用性 天玄区块链引入开发部署工具、区块链浏览器等工具来提升系统的易用性，大幅缩短建链以及应用部署的时间： 开发部署工具 SDK（天玄目前只支持 Java SDK） 区块链浏览器 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-19 13:26:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduce/tianxaun-chain-ver.html":{"url":"introduce/tianxaun-chain-ver.html","title":"版本信息","keywords":"","body":"版本信息 当前版本 v1.0.1 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/depoly-tianxaun-chain/":{"url":"quick-start/depoly-tianxaun-chain/","title":"快速搭建天玄链","keywords":"","body":"快速搭建天玄链 本章节会讲解如何使用脚本工具在 Linux 服务器上快速搭建一条天玄链： 硬件要求 软件要求 构建节点安装包 安装并启动节点 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/depoly-tianxaun-chain/hardware-requirement.html":{"url":"quick-start/depoly-tianxaun-chain/hardware-requirement.html","title":"硬件要求","keywords":"","body":"硬件要求 硬件配置要求 配置 最低配置 推荐配置 内存 2GB 4GB CPU核心数 2核 4核 硬盘大小 100G 1T 网络带宽 1Mb 10Mb 操作系统 CentOS 7+ (推荐)、Ubuntu18+ 网络及端口要求 至少需要开放7个端口，供链节点部署使用。 端口信息 端口号 网关P2P端口 100 ~ 网关HTTP端口 8580 ~ 网关RPC端口 8180 ~ 网关监听端口 7580 ~ 链发现端口 30303 ~ 链共识端口 9080 ~ 链监听端口 7180 ~ 如果机器配置了安全组规则，上述端口需要能和其他公网节点双向通信 (开通公网入方向和公网出方向权限) 。 具体需要打开的端口号根据单机启动的节点而定。默认情况下，对应端口号如表格中所示。 需注意，当一台机器上需要运行多个节点时，为了防止端口冲突，脚本会按照节点序号自动往后递增 1 。 以网关 P2P 端口为例，在一台机器上运行两个节点时，只需在网络安全组中将需要将 100 和 101 都打开即可。 端口配置详情请参考：构建节点安装包配置说明 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/depoly-tianxaun-chain/software-requirement.html":{"url":"quick-start/depoly-tianxaun-chain/software-requirement.html","title":"软件要求","keywords":"","body":"软件要求 要求清单 天玄链和网关提供一键安装部署的脚本，方便用户快速搭建一条测试链。 在执行此脚本前，依赖的软件需要预先在执行脚本的服务器上安装好，具体的软件清单如下： 运行 \"节点安装包构建脚本\" 需要： Oracle JDK - 1.8 Maven - 3.3.9 Git Crudini 运行 \"节点安装与启动脚本\" 需要： Oracle JDK - 1.8 Crudini 安装教程 Oracle JDK [1.8] 安装 # 创建新的文件夹，安装Java 8或以上的版本，将下载的jdk放在software目录 # 从Oracle官网( https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html ) 选择Java 8版本下载，推荐下载jdk-8u201-linux-x64.tar.gz mkdir /software # 解压jdk tar -zxvf jdk-8u201-linux-x64.tar.gz # 配置Java环境，编辑/etc/profile文件 vim /etc/profile # 打开以后将下面三句输入到文件里面并退出 export JAVA_HOME=/software/jdk1.8.0_201 #这是一个文件目录，非文件 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # 生效profile source /etc/profile # 查询Java版本，出现的版本是自己下载的版本，则安装成功。 java -version 配置 jdk 的熵池 打开 $JAVA_PATH/jre/lib/security/java.security 这个文件，找到下面的内容： # 将 securerandom.source=file:/dev/random # 替换成 securerandom.source=file:/dev/urandom Maven [3.3.9] 安装 # 下载安装文件 cd /software wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz # 解压maven tar -zxvf apache-maven-3.3.9-bin.tar.gz # 配置环境变量 # 使用vim编辑/etc/profile文件 vim /etc/profile # 在 /etc/profile 文件末尾增加以下配置： MAVEN_HOME=/software/apache-maven-3.3.9 export PATH=${MAVEN_HOME}/bin:${PATH} # 生效profile source /etc/profile # 查询Maven版本，出现的版本是自己下载的版本，则安装成功。 mvn -v 国内服务器有需要的话，在 Maven 的 setting.xml 中更新一下 aliyun 的镜像源，后续在执行 Maven 执行的时候，下载速度会快一些。 nexus-aliyun central Nexus aliyun >http://maven.aliyun.com/nexus/content/groups/public Git 安装 下载开发部署工具的源码需要依赖 Git ，安装命令如下： # Ubuntu 系统 sudo apt install -y git # CentOS 系统 sudo yum install -y git 配置 git 密钥 (可选) ： 将自己的 github 账户私钥上传到 ~/.ssh/ 目录下 修改私钥访问权限 chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub Crudini 安装 机器需要安装 crudini 。 # Ubuntu 系统 sudo apt-get install -y crudini # CentOS 系统 sudo yum install -y crudini 检查安装结果。 type crudini # 返回类似如下信息即为安装成功： # crudini is /usr/bin/crudini 如果直接安装失败，则需要配置 epel 源。 #配置yum源为aliyun wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum clean all yum makecache sudo yum -y install crudini Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/depoly-tianxaun-chain/build.html":{"url":"quick-start/depoly-tianxaun-chain/build.html","title":"构建节点安装包","keywords":"","body":"构建节点安装包 本教程脚本运行环境需要在 Linux 系统中进行，系统版本要求请见：硬件需求。 下载物料包 cd ~ #使用 root 作为起始工作目录 git clone https://github.com/TianXuan-Chain/thanos-package-generate.git #拉取物料包 cd ./thanos-package-generate #进入工作目录 主要配置 找到 config.ini 文件。 vim config.ini #修改配置文件 [chain-nodes] 配置项 找到 [chain-nodes] 部分的配置，初始化服务器和节点的数量 [chain-nodes] # 格式为 : nodeIDX=p2p_ip listen_ip num agent # IDX为索引, 从0开始增加. # p2p_ip => 服务器上用于p2p通信的网段的ip，多数时候都是公网ip. # private_ip => 服务器的内网ip # listen_ip => 服务器上的监听端口, 用来接收rpc、channel的链接请求, 建议默认值为\"0.0.0.0\". # num => 在服务器上需要启动的节点的数目. # agent => 机构名称, 若是不关心机构信息, 值可以随意, 但是不可以为空. # node0 = 111.111.111.111 10.10.0.1 0.0.0.0 1 agent node0=101.35.234.166 10.0.16.7 0.0.0.0 1 agency 如果只用作测试需求，建议只运行一个节点即可。 # 单节点示例配置如下，请修改后使用 node0=101.35.234.166 10.0.16.7 0.0.0.0 1 agency 如果想要部署多节点网络，按照下面格式配置即可。 # 多节点示例配置如下，请修改后使用 node0=101.35.234.166 10.0.16.7 0.0.0.0 2 agency node1=101.44.225.133 10.0.11.5 0.0.0.0 1 agency1 上面配置中初始设置两个服务器 agency 和 agency1，其中 agency 上运行两个节点，agency1 上运行一个节点，一共三个节点。 [chain-ports] 和 [gateway-ports] 配置项 一般使用默认值即可。但需要在服务器对应安全组中打开，并注意以下两个事项： 如果一台服务器上启动多个节点，节点使用的端口会以默认端口为基准往后递增 1 检查默认配置的端口在服务器上是否被占用，如被占用则需要修改，Linux 系统可使用 sudo netstat -tlnp | grep 端口号 命令查询 该部分配置与 服务器端口开放要求 部分相对应。 # 端口配置, 一般不用做修改, 使用默认值即可. [chain-ports] peer_discovery_port = 30303 #p2p端口 peer_rpc_port = 9080 #rpc端口 listen_gateway_port = 7580 #监听gateway的端口，用于接收交易 [gateway-ports] peer_rpc_port = 100 #peer_rpc端口,用于gateway之间互发消息 web3_rpc_port = 8180 #web3_rpc_port端口，用于向web3sdk提供rpc接口服务 web3_http_port = 8580 #web3_http_port端口，用于向web3sdk提供http接口服务 listen_chain_port = 7180 #监听chain的端口，用于接收共识完成的区块 生成安装包 配置修改好后，在项目目录下，执行以下命令。 bash build_chain.sh build 中间会有 thanos-common ，thanos-gateway ，thanos-chain 等应用的下载和 Maven 打包，需要等待片刻。当前目录下生成 build 目录后，表明脚本执行成功。 查看生成的 build 目录结构（配置了多服务器多节点时）。 tree -L 1 build build ├── 101.35.234.160_agency.tar.gz ├── 43.130.226.84_agency.tar.gz └── follow 其中，101.35.234.160_agency.tar.gz 和 43.130.226.84_agency.tar.gz 即为节点的安装包。 将压缩包上传到 Ip 对应的服务器上，就可以进行节点的安装和运行即可。 其他配置说明 注：下面介绍的相关配置，没有必要不需要改动 [common] 配置项 配置一些基础信息 指定天玄相关库的 github 地址，便于拉取代码 打包 jar 后的存放路径 (可以不配置) [common] # 物料包拉取thanos-common/chain和gateway源码的github地址. common_github_url = https://github.com/TianXuan-Chain/thanos-common.git chain_github_url = https://github.com/TianXuan-Chain/thanos-chain.git gateway_github_url = https://github.com/TianXuan-Chain/thanos-gateway.git # 物料包拉取天玄源码之后, 会将源码保存在本地的目录, 保存的目录为thanos-common，thanos-chain，thanos-gateway # chain_src_local = /root/src # 源码打成jar包的本地存放地址 # jar_local_path=/root/jar [tls] 和 [crypto] 配置项 国密和密钥算法相关配置。 [tls] gm_tls_open = false #tls是否使用国密，如不使用，则采取传统ECDSA。 gateway_need_tls = false #gateway是否需要开启tls [crypto] secure_key_type = ECDSA #节点公私钥对的生成算法 ECDSA 或 ED25519 或 SM sharding_number = 1 #节点所属分片号，保持默认为 1 即可 cipher_key_type = AES #节点对称密钥的算法算法：AES 或 SM4 [maven-repo] 配置项 注意：该配置暂时已废弃，目前可忽略。 Maven 私库配置，可以将打包好的 jar 包上传到私有库中，对应的 Maven 配置文件里也需配置相应的 Maven 私库以及凭证信息。 # mvn私库配置 [maven] release_url=\"\" release_repositoryId=\"\" snapshot_url=\"\" snapshot_repositoryId=\"\" Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/depoly-tianxaun-chain/run.html":{"url":"quick-start/depoly-tianxaun-chain/run.html","title":"安装并启动节点","keywords":"","body":"安装并启动节点 安装节点 将生成的安装包传至相应 Ip 的服务器上，解压并安装各节点。 tar -zxvf 101.35.234.160_agency.tar.gz #注意替换成自己的压缩包名 cd 101.35.234.160_agency #进入工作目录 bash install_node.sh #运行安装脚本 执行成功后，会在每个 node 目录中生成 thanos-chain 和 thanos-gateway 两个目录。 启动节点应用 启动四个节点应用，顺序为先启动 thanos-chain 应用，再启动 thanos-gateway 应用。 # 以node0为例 cd node0/thanos-chain bash start_chain.sh 当配置的初始节点应用均已启动，则链启动完成。脚本中每个进程默认设置占用 1g 的内存，如果需要修改，可以进入脚本中直接修改运行指令。 运行脚本会后台启动应用，运行结果不会直接输出，请转至相应的 logs 目录下查看运行日志。 # 以node0为例 cd node0 tail -f thanos-chain/logs/thanos-chain.log | grep 'empty do commit cost' #如果持续打印该消息，说明节点chain应用启动成功并参与共识。 启动节点网关 节点应用启动成功后，再启动 thanos-gateway # 以node0为例 cd node0/thanos-gateway bash start_gateway.sh 网关启动后查看 log 日志如下，则启动成功 # 以node0为例 cd node0 cat thanos-gateway/logs/thanos-gateway.log |grep 'INFO [main] Main start success!!' #如果打印该消息，说明节点gateway应用启动成功。 其他问题 内存不足 如果在运行程序时，遇到启动失败且无任何日志时，可能时服务器内存不住的原因。脚本中每个进程默认设置占用 1g 的内存，所以 chain 和 gateway 总共会占用至少 2g 的内存。 如果需要修改，可以直接进入 start-chain.sh 以及 start-gateway.sh 脚本中修改运行指令。 start-chain.sh nohup java -Xmx256m -Xms256m -Xmn256m -Xss4M -XX:SurvivorRatio=8 -jar thanos-chain.jar >/dev/null & start-gateway.sh nohup java -Xmx256m -Xms256m -Xmn256m -Xss4M -XX:SurvivorRatio=8 -jar thanos-gateway.jar >/dev/null & rpc 端口绑定失败 如果节点网关 rpc 端口绑定失败，thanos-gateway.log 中会出现如下报错信息 java.net.BindException: Cannot assign requested address (Bind failed) at java.net.PlainSocketImpl.socketBind(Native Method) at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387) at java.net.ServerSocket.bind(ServerSocket.java:375) at java.net.ServerSocket.(ServerSocket.java:237) at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231) at com.thanos.gateway.jsonrpc.RpcServiceProvider.loadServerSocket(RpcServiceProvider.java:69) at com.thanos.gateway.jsonrpc.RpcServiceProvider.(RpcServiceProvider.java:44) at com.thanos.gateway.jsonrpc.JsonRpcInit.init(JsonRpcInit.java:14) at com.thanos.gateway.Main.main(Main.java:31) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:65) 需要查看 node0/thanos-gateway/resource/thanos-gateway.conf 配置文件并找到 rpc.address 条目，例如 address=10.8.0.1:8180 检查对应的 8180 端口是否在安全组中配置打开 检查 Ip 地址是否为内网地址 (目前 rpc 限制为仅内网可访问，而 http 为外网访问) 检查并修改完成后，重新执行 start_gateway.sh 运行网关，注意如果上一次运行的进程如果未关闭，需要先手动关闭。 ps -ef | grep java #查询运行中的 java 进程 kill -9 进程号 #找到对应的进程，并关闭 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quick-start/deploy-tianxaun-app.html":{"url":"quick-start/deploy-tianxaun-app.html","title":"应用部署示例","keywords":"","body":"应用部署示例 在开始本教程前，请先确保已经按照 快速搭建天玄链 在服务器上部署好了一条测试链。 本教程将在 Windows 环境下，使用 IntelliJ IDEA 进行，方便读者基于此 Demo 进行开发，所以请确保在运行 Demo 代码的机器上具备以下环境。 IDE：进入 IntelliJ IDEA 官网 ，下载并安装社区版 IntelliJ IDEA Oracle JDK：Java应用需要依赖 Oracle JDK ，且 JDK 版本不低于 1.8.0u201 Maven：项目需要依赖 Maven ，且版本不低于 3.3.9 下载Demo物料包 从 GitHub 上下载 Demo 示例代码，该示例代码会使用天玄的 Web3j SDK 与天玄链交互，模拟部署应用合约并向合约发起交易。 由于依赖的 thanos-web3j.jar 还未发布到 Maven 公共库，所以当前阶段也需要手动安装一下，同样 thanos-web3j 依赖的 thanos-common 也是。以确保在本地机器的 Maven 本地仓库中构建完整的依赖。 git clone https://github.com/TianXuan-Chain/thanos-package-generate.git git clone https://github.com/TianXuan-Chain/thanos-common.git git clone https://github.com/TianXuan-Chain/thanos-web3j.git git clone https://github.com/TianXuan-Chain/thanos-demo.git 配置 IntelliJ IDEA 配置 JDK 图1. 配置 JDK 配置 Maven 图2. 配置 Maven 编译 thanos-common 首先，由于 thanos-common 依赖于 bctls-gm-jdk15on.jar 文件，所以请先下载好的物料包中找到 thanos-package-generate/dependenies/jar/bctls-gm/bctls-gm-jdk15on.jar 文件。也可以直接在此处获取：bctls-gm-jdk15on.jar 文件下载 然后执行下面命令将其加载到本地 Maven 仓库中。 mvn install:install-file -Dfile=bctls-gm-jdk15on.jar -DgroupId=org.bouncycastle -DartifactId=bctls-gm-jdk15on -Dversion=0.1 -Dpackaging=jar 最后，使用 IntelliJ IDEA 打开 thanos-common 项目，按照下图所示执行 maven install（也可以直接在 cmd 中执行）。 图3. 执行 maven install 编译执行成功后，thanos-common.jar 会被加载到本地仓库中。 编译 thanos-web3j 使用 IntelliJ IDEA 打开 thanos-web3j 项目，执行 gradle publishToMavenLocal （如果本地安装了 gradle ，也可以通过 cmd 执行）。 图4. 执行 gradle publishToMavenLocal 执行成功，thanos-web3j.jar 将会被加载到本地 Maven 库中。 运行 Demo 应用代码 使用 IntelliJ IDEA 打开 thanos-demo 项目，配置 Maven 和 JDK ，注意 Maven 本地仓库路径需要和打包 thanos-web3j 时的 Maven 本地仓库路径一致。 而后根据自己部署的测试链 ip 和 port 修改 thanos-web3j.conf 配置文件。 gateway = { # List of gateway peers to send msg rpc.ip.list = [ #\"127.0.0.1:8082\" #\"10.246.199.210:8182\" #\"127.0.0.1:8082\",\"127.0.0.1:8182\" ] web3Size = 3 #connection check interval (s) checkInterval = 60 # List of gateway peers http port to send msg http.ip.list = [ #\"127.0.0.1:8200\" \"101.35.234.159:8580\" ] } resource { # logConfigPath = \"F:\\\\myJava\\\\blockchain3.0\\\\thanos-web3j\\\\src\\\\main\\\\resources\\\\logback.xml\" } #tls settings, such as path of keystore,truststore,etc tls { needTLS = false keyPath=\"F:\\\\myJava\\\\blockchain3.0\\\\thanos-gateway\\\\src\\\\main\\\\resources\\\\ec-tls2\\\\node.key\" certsPath=\"F:\\\\myJava\\\\blockchain3.0\\\\thanos-gateway\\\\src\\\\main\\\\resources\\\\ec-tls2\\\\chain.crt\" } #crypto settings, such as signECDSA, getHash, etc crypto { #JCA cryptoprovider name. providerName=\"SC\" #JCA sign Algorithm,such as ECDSA, ED25519 etc sign.algorithm=\"ECDSA\" #sign.algorithm=\"ED25519\" #sign.algorithm=\"SM\" #Used for create JCA MessageDigest hash.alg256=\"ETH-KECCAK-256\" hash.alg256=\"ETH-KECCAK-256-LIGHT\" hash.alg512=\"ETH-KECCAK-512\" } 配置信息如下： gateway： SDK 和天玄链节点网关交互的相关配置 resource： 日志的路径配置 tls： 是否开启 tls 以及 tls 相关的证书和私钥的配置 (当前默认关闭，是否开启需要和节点的配置保持一致) crypto： 加密相关配置 当前教程，只需要将自己的 http 链接配置到 http . ip . list 中即可。如果按照之前教程部署的链，没有修改过默认端口，则直接修改为 [节点服务器 ip : 8580] 即可。 或者请查询节点网关的配置文件 thanos-gateway.conf 中所设置的端口号，更多信息请见：网关配置说明。 配置完成并加载 Maven 依赖后运行 SimpleTokenHttpTest.main 。 图5. 运行程序 该方法会使用 thanos-web3j 模拟部署一个简单的 Token 应用到测试链上，并模拟执行 Token 转移交易。成功运行后，等待片刻，你会看到如下信息 图6. 运行结果 返回应用合约地址，表明合约部署成功，后面的 transder from 以及 transfer to 等信息是模拟执行的合约交易结果。 想了解更多关于 Web3j SDK 的使用细节，请参考：Java SDK Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/":{"url":"installation-manual/tianxaun-chain/","title":"天玄链","keywords":"","body":"天玄链 天玄链节点分为应用和网关两部分，本章节会详细讲解如何手动部署天玄应用： 打包可执行文件 安装 配置说明 证书说明 日志说明 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/executable-file.html":{"url":"installation-manual/tianxaun-chain/executable-file.html","title":"打包可执行文件","keywords":"","body":"打包可执行文件 注意：下述流程需要在同一台机器上完成，因为涉及到本地 Maven 包相互依赖的问题 完成下述步骤后，将会获得 thanos-chain.jar 和 thanos-gateway.jar 两个可执行 jar 包。 安装依赖 获取可执行文件之前，需要先安装如下软件 Oracle JDK 1.8 Maven 3.3.9 git 上述软件的安装教程可见：软件安装 打包 thanos-common thanos-common 包需要依赖于 bctls-gm-jdk15on.jar ，需要提前加载到本地库。该依赖包可在此处获取：https://github.com/TianXuan-Chain/thanos-package-generate/blob/main/dependencies/jar/bctls-gm/bctls-gm-jdk15on.jar 获取后将其加载到本地的 Maven 仓库中 mvn install:install-file -Dfile=bctls-gm-jdk15on.jar -DgroupId=org.bouncycastle -DartifactId=bctls-gm-jdk15on -Dversion=0.1 -Dpackaging=jar 该依赖包加载成功后，开始 thanos-common 编译打包 # thanos-common 代码已经开源，从 github 上拉取下载 git clone https://github.com/TianXuan-Chain/thanos-common.git # 进入项目文件夹 cd thanos-common # 编译 mvn clean install -Dmaven.test.skip=true 打包命令执行后，会在 target 目录下生成 thanos-common.jar 包，并且该 jar 包会被自动加载到本地的 Maven 仓库中 打包 thanos-gateway thanos-gateway 项目依赖于 thanos-common ，按照本教程流程，thanos-common.jar 以应被加载到了本地 Maven 库中。直接编译打包本项目即可。 # thanos-gateway 代码已经开源，从 github 上拉取下载 git clone https://github.com/TianXuan-Chain/thanos-gateway.git # 进入项目文件夹 cd thanos-gateway # 编译 mvn clean install -Dmaven.test.skip=true 打包命令执行成功后，会在 target 目录下生成 thanos-gateway.jar。 打包 thanos-chain thanos-chain 应用，除了依赖 thanos-common.jar 以外，还依赖于 solcJ-all-0.4.25.jar 。按照文档执行顺序，thanos-common.jar 以应被加载到了本地 Maven 库中，还需要手动加载一下 solcJ-all-0.4.25.jar 到本地库，该 jar 包可在此处下载：https://github.com/TianXuan-Chain/thanos-package-generate/blob/main/dependencies/jar/solc/solcJ-all-0.4.25.jar # 将 solcJ-all-0.4.25.jar 加载到本地库 mvn install:install-file -DgroupId=org.ethereum -DartifactId=solcJ-all -Dversion=0.4.25 -Dversion=0.4.25 -Dpackaging=jar -Dfile=solcJ-all-0.4.25.jar 该依赖包加载成功后，开始 thanos-chain 编译打包。 # thanos-chain 代码已经开源，从 github 上拉取下载 git clone https://github.com/TianXuan-Chain/thanos-chain.git # 进入项目文件夹 cd thanos-chain # 编译 mvn clean install -Dmaven.test.skip=true 打包命令执行成功后，会在target目录下生成 thanos-chain.jar。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:22:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/installation.html":{"url":"installation-manual/tianxaun-chain/installation.html","title":"安装","keywords":"","body":"安装 本章介绍天玄节点应用所需的必要安装和配置。本章通过在单机上部署一条天玄测试链，来帮助用户掌握部署流程。 硬件要求 配置 最低配置 推荐配置 CPU 1.5GHz 2.4GHz 内存 2GB 4GB 核心数 2核 4核 网络带宽 1Mb 10Mb 操作系统 CentOS (7及以上 64位) 或 Ubuntu(18.04 64位) JAVA JDK 1.8 天玄链安装搭建 前置依赖软件 Oracle JDK 1.8 GmSSL-v2（该软件只支持 Linux 系统） GmSSL-v2 的安装流程如下 # 注意需要安装 GmSSl-2.0，当前 GmSSL 最新代码为 3.0，需要指定 2.0 版本 git clone --branch GmSSL-v2 --single-branch https://github.com/guanzhi/GmSSL.git cd GmSSL/ ./config make sudo make install sudo cp libcrypto.so.1.1 libssl.so.1.1 /lib64 由于 gmssl 默认安装在 usr/local/bin 路径下，如果当前 linux 系统的 $PATH 变量不包含该路径，需要添加 vim /etc/profile #在文件末尾处添加如下语句 export PATH=/usr/local/bin:${PATH} source /etc/profile 执行完成后，查询版本号，如果顺利返回，说明 gmssl 安装完成。 gmssl version 创建操作目录 创建当前链节点的操作目录，以 node0 为例。 cd ~ && mkdir -p thanos-chain/node0 && cd thanos-chain/node0 然后在节点目录下创建 database ，logs 和 resource 子目录。其中，database 目录用于存放节点身份信息配置、创世块配置 以及 生成的链区块；logs 目录用于存放链执行日志；resource 目录用于存放节点的总配置文件。 mkdir database logs resource 还需在 resource 目录下创建 tls 文件夹，用于放置证书等文件 mkdir resource/tls 添加可执行文件 获取可执行文件 thanos-chain.jar（获取方式见 获取可执行文件），并放在节点操作目录下，如 ~/thanos-chain/node0/ 创建链证书和机构证书 在配置节点前，需要先准备好链证书、机构证书和机构私钥等信息，用于签发节点证书。具体证书说明见：证书说明 链和机构证书的创建流程如下： 1）创建当前链的证书目录 cd ~ && mkdir -p thanos-chain/ca && cd thanos-chain/ca 2）添加证书配置文件 3）创建链私钥、证书和机构私钥，证书 cert.cnf , 内容如下 [ca] default_ca=default_ca [default_ca] default_days = 365 default_md = sha256 [req] distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] countryName = CN countryName_default = CN stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = ZheJiang localityName = Locality Name (eg, city) localityName_default = HangZhou organizationalUnitName = Organizational Unit Name (eg, section) organizationalUnitName_default = netease commonName = Organizational commonName (eg, netease) commonName_default = netease commonName_max = 64 [ v3_req ] # Extensions to add to a certificate request basicConstraints = CA:FALSE keyUsage = nonRepudiation, digitalSignature, keyEncipherment [ v4_req ] basicConstraints = CA:TRUE 3）创建链私钥、证书和机构私钥、证书，按需求从国密和非国密中二选一即可，本教程请使用非国密 非国密 # 1. 生成根ca的私钥ca.key与自签名证书ca.crt gmssl genrsa -out ca.key 2048 gmssl req -new -x509 -days 3650 -key ca.key -out ca.crt # 2. 生成机构私钥agency.key与证书agency.crt (由根ca签发) gmssl genrsa -out agency.key 2048 gmssl req -new -key agency.key -config cert.cnf -out agency.csr gmssl x509 -req -days 3650 -CA ca.crt -CAkey ca.key -CAcreateserial -in agency.csr -out agency.crt -extensions v4_req -extfile cert.cnf 国密 # 1. 生成根ca的私钥ca.key与自签名证书ca.crt gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out ca.key gmssl req -new -x509 -days 365 -key ca.key -sm3 -out ca.crt # 2. 生成机构私钥agency.key与证书agency.crt (由根ca签发) gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out agency.key gmssl req -new -sm3 -key agency.key -config cert.cnf -out agency.csr gmssl x509 -req -days 3650 -CA ca.crt -CAkey ca.key -in agency.csr -out agency.crt -CAcreateserial -sm3 -extensions v4_req -extfile cert.cnf 配置单节点 本节主要以 node0 节点为例，介绍如何进行节点信息配置，包括节点身份信息、网络端口配置等。其他节点的配置流程相同。 创建节点密钥及证书 在 ~/thanos-chain/ca 目录下，执行如下命令，生成指定算法的节点密钥，并使用机构私钥签发节点证书。 非国密 # 1. 生成节点私钥和节点证书 gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:secp256k1 -out node.key gmssl req -new -key node.key -config cert.cnf -out node.csr gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -extensions v3_req -extfile cert.cnf gmssl x509 -text -in node.crt | sed -n '5p' | sed 's/://g' | tr \"\\n\" \" \" | sed 's/ //g' | sed 's/[a-z]/\\u&/g' | cat >node.serial # 2. 生成证书链文件 cat ca.crt agency.crt node.crt > chain.crt 国密 # 1. 生成节点私钥和节点证书 gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out node.key gmssl req -new -sm3 -key node.key -config cert.cnf -out node.csr gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -sm3 -extensions v3_req -extfile cert.cnf gmssl x509 -text -in node.crt | sed -n '5p' | sed 's/://g' | tr \"\\n\" \" \" | sed 's/ //g' | sed 's/[a-z]/\\u&/g' | cat >node.serial # 2. 生成证书链文件 cat ca.crt agency.crt node.crt > chain.crt 将生成的 node0 节点的密钥及证书添加至 ~/thanos-chain/node0/resource/tls 目录下。 cp ca.crt agency.crt ~/thanos-chain/node0/resource/tls mv node.* chain.crt ~/thanos-chain/node0/resource/tls 添加节点配置 本节主要介绍节点部署需要添加的配置。配置文件中各配置项的具体含义参见 thanos-chain 配置说明 1）在 ~/thanos-chain/node0/resource/ 目录下 添加节点的总配置文件 thanos-chain.conf 和日志管理配置 chain-logback.xml 。 thanos-chain.conf 内容如下。注意，涉及路径的配置项必须是绝对路径，如以下配置项： resource . database . dir resource . logConfigPath tls . keyPath 和 tls . certsPath network { peer.rpc.ip = 127.0.0.1 peer.bind.ip = 0.0.0.0 peer.listen.discoveryPort = 30303 peer.listen.rpcPort = 9080 peer.channel.read.timeout = 60 peer.discovery = { # List of the seed peers to start # the search for online peers ip.list = [ ] } // need consistency pattern of each node transferDataEncrypt = 1 // default false epollSupport = false nettyPoolByteBuf = false gateway { localListenAddress = 7580 remoteServiceAddress = \"127.0.0.1:7180\" pushTxsQueueSize = 6 } } consensus { // 1 = MultipleOrderedProposers; // 2 = RotatingProposer; proposerType = 2 contiguousRounds = 1 maxPackSize = 50000 maxCommitEventNumInMemory = 100 maxPrunedEventsInMemory = 4 // reimportUnCommitEvent = true poolLimit = 3000 roundTimeoutBaseMS = 5000 parallelProcessorNum = 8 } state { checkTimeoutMS = 1500 maxCommitBlockInMemory = 5 } resource { database { needEncrypt = false encryptAlg = AES # place to save physical livenessStorage files # must use absolute path dir = \"/root/thanos-chain/node0/database\" } logConfigPath = \"/root/thanos-chain/node0/resource/chain-logback.xml\" } vm.structured { trace = false dir = vmtrace initStorageLimit = 10000 } #tls settings, such as path of keystore,truststore,etc tls { keyPath= \"/root/thanos-chain/node0/resource/tls/node.key\" certsPath= \"/root/thanos-chain/node0/resource/tls/chain.crt\" } chain-logback.xml 内容如下： %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE ./logs/thanos-chain.log ./logs/thanos-chain-%d{yyyy-MM-dd-'h'HH}.log 720 50GB %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE 0 flush occurs often) --> 100 TRACE 3）在 ~/thanos-chain/node0/database/ 目录下 添加节点身份配置文件 nodeInfo.properties 和 创世块配置文件 genesis.json 。 在配置 nodeInfo.properties 前，需要先为节点生成 privateKey 和 id ，请先找到并进入 thanos-common.jar 所在的目录，并执行以下指令 # \"ECDSA\" 是链选用的密钥算法，1 分片链的 id ，当前天玄还未实现分片，所以默认为 1 即可 java -jar ./thanos-common.jar \"ECDSA\" 1 1>>./node.private 打开 node.private 文件，会看到如下信息： #ECDSA nodeIdPrivateKey = 0100017548b67007132aa98b0e924ce606624899df5760955a4d8f2a2dbda572d90f09 nodeId = 7b7bd52bef9840c91a8e6e51e2fab685916c60d770b8e5f0821a80cdb4b0dafccba540aa30b340662d6eebc70e2dd6e6bbcbac67af1377683bba18121ac6ede8 publicKey = 010001047b7bd52bef9840c91a8e6e51e2fab685916c60d770b8e5f0821a80cdb4b0dafccba540aa30b340662d6eebc70e2dd6e6bbcbac67af1377683bba18121ac6ede8 而后，配置 nodeInfo.properties 文件，替换 nodeIdPrivateKey 和 nodeId 部分。 # ECDSA name= xiaoming #节点名称 agency= agency #节点所属机构名称 caHash= caHash01 #节点证书序列号，暂未用到，可随意填 #节点私钥，从node.private文件获取 nodeIdPrivateKey= 0100017548b67007132aa98b0e924ce606624899df5760955a4d8f2a2dbda572d90f09 #节点id，从node.private文件获取 nodeId= 7b7bd52bef9840c91a8e6e51e2fab685916c60d770b8e5f0821a80cdb4b0dafccba540aa30b340662d6eebc70e2dd6e6bbcbac67af1377683bba18121ac6ede8 # AES nodeEncryptKey= c9ec17b81d5abf18b979693faacbf917 # SM4 # nodeEncryptKey=a77ce8a55dbc209f052d6be716963ec2 注意：在配置 nodeInfo.properties 文件时，内容最好手动输入，否则在读取配置的时候可能会出现编码问题，nodeIdPrivateKey 和 nodeId 的值可以复制粘贴。否则，在运行节点时可能会遇到如下错误： Exception in thread \"main\" org.spongycastle.util.encoders.DecoderException: exception decoding Hex string: 33410 at org.spongycastle.util.encoders.Hex.decode(Hex.java:132) at com.thanos.chain.config.SystemConfig.getMyKey(SystemConfig.java:420) at com.thanos.chain.config.SystemConfig.getNodeId(SystemConfig.java:433) at com.thanos.chain.network.peer.PeerManager.(PeerManager.java:103) at com.thanos.chain.initializer.ComponentInitializer.init(ComponentInitializer.java:21) at com.thanos.chain.Main.main(Main.java:23) Caused by: java.lang.ArrayIndexOutOfBoundsException: 33410 at org.spongycastle.util.encoders.HexEncoder.decode(HexEncoder.java:176) at org.spongycastle.util.encoders.Hex.decode(Hex.java:128) ... 5 more genesis.json 内容如下，其中 validatorVerifiers 为组网节点身份信息 key 为节点公钥 value 为节点身份信息。 请替换 validatorVerifiers 中的条目信息为自己节点密钥信息。如将 key (如下配置中的 0100....ede8) 替换为自己的节点公钥将 node.private 文件中的 publicKey 。 { \"validatorVerifiers\": { \"010001047b7bd52bef9840c91a8e6e51e2fab685916c60d770b8e5f0821a80cdb4b0dafccba540aa30b340662d6eebc70e2dd6e6bbcbac67af1377683bba18121ac6ede8\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming\", \"agency\": \"agency\", \"caHash\": \"caHash01\" } }, \"committeeAddrs\": [], \"operationsStaffAddrs\": [], \"voteThreshold\": \"2/3\", \"alloc\": { \"5db10750e8caff27f906b41c71b3471057dd2004\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" }, \"31e2e1ed11951c7091dfba62cd4b7145e947219c\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" }, \"ee0250c19ad59305b2bdb61f34b45b72fe37154f\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" } }, \"maxShardingNum\" : 1024, \"shardingNum\": 1, \"nonce\": \"0x0000000000000000\", \"difficulty\": \"0x100000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x1000000000\", \"startEventNumber\": \"12\" } 至此，单节点配置完成，可以启动。启动方法为：在节点目录下 ~/thanos-chain/node0/ ，运行如下指令启动节点： java -Xmx256m -Xms256m -Xmn256m -Xss4M -jar thanos-chain.jar 如果运行时遇到如下报错: 15:46:30.639 ERROR [c.t.c.u.SSLUtil] loadSSLContext error! java.lang.SecurityException: JCE cannot authenticate the provider BC at javax.crypto.JceSecurity.getInstance(JceSecurity.java:118) at javax.crypto.KeyAgreement.getInstance(KeyAgreement.java:270) at org.bouncycastle.jcajce.util.ProviderJcaJceHelper.createKeyAgreement(Unknown Source) 需要手动将 bcprov-jdk15on-1.66.jar 包放置到 $JAVA_HOME/jre/lib/ext 目录下，可从此处下载：https://github.com/TianXuan-Chain/thanos-package-generate/blob/main/dependencies/jar/bcprov-jdk15on-1.66.jar 配置多节点 当多个节点进行组网时，需要完成以下操作： 1）配置所有节点 重复 配置单节点 的步骤完成各共识节点的配置。 2）修改所有节点的 genesis.json 配置文件 配置每个节点的 genesis.json 文件中的 validatorVerifiers 字段，使其包含所有组网节点的公钥和身份信息。举例如下，假设组网节点由 3 个节点组成，其节点信息如下： #node0 的 nodeInfo.properties文件内容 name=xiaoming agency=agency01 caHash=caHash01 nodeIdPrivateKey=be5368036e55a89f9d01486f8b50d4a0076b644eb1dfeff5ec879d93d534bdfe nodeId=0d3a176a1e51f68e04deda9c6437543dcd87db185b970476c611052b106a2422af7c496e09fd7f6215284ed83cb3b66bc24f9a318eded9ec7f6722fc52616e29 #publicKey=040d3a176a1e51f68e04deda9c6437543dcd87db185b970476c611052b106a2422af7c496e09fd7f6215284ed83cb3b66bc24f9a318eded9ec7f6722fc52616e29 #node2 的 nodeInfo.properties文件内容 name=xiaoming01 agency=agency02 caHash=caHash02 nodeIdPrivateKey=a2d68d25918e3d0f8962506517df742ef5c354ec8b516a54315e26e696b82198 nodeId=7cbf053e81cc2cd1896fc5470c428cad1432cc53d19976a40fa70cae0e3a4415cc1648fc37dc07b5fef0f2a7da71093a88f308adb0c8ca24b0dfe983f78a04f7 #publicKey=047cbf053e81cc2cd1896fc5470c428cad1432cc53d19976a40fa70cae0e3a4415cc1648fc37dc07b5fef0f2a7da71093a88f308adb0c8ca24b0dfe983f78a04f7 #node3 的 nodeInfo.properties文件内容 name=xiaoming02 agency=agency03 caHash=caHash03 nodeIdPrivateKey=d9694bc7257b6e11d5a6d3076b28fd9011b46fcc036fbfddf2d6f87866673480 nodeId=0be9f1ad6053103cd185995a34e92047eeeccfdeec6db7106d365f35603178ecf3e15e9a69cfbff9c950097fd7acf5190cc03cd7983261ac7f70fa82ca48ff93 #publicKey=040be9f1ad6053103cd185995a34e92047eeeccfdeec6db7106d365f35603178ecf3e15e9a69cfbff9c950097fd7acf5190cc03cd7983261ac7f70fa82ca48ff93 则需要配置这三个节点的 genesis.json 中的 validatorVerifiers 字段，内容如下。该字段包含所有共识节点的公钥和身份信息（ key 为节点公钥，value 为节点身份信息）。 \"validatorVerifiers\": { \"04142abb8c8604ae81aebd56927f372efb225052833316de6e19eb121ae12de6c42c333647b3f26642dd636b8cfd7510d1444c93caf91a535b60917ecb949ddc24\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming\", \"agency\": \"agency01\", \"caHash\": \"caHash01\" }, \"047cbf053e81cc2cd1896fc5470c428cad1432cc53d19976a40fa70cae0e3a4415cc1648fc37dc07b5fef0f2a7da71093a88f308adb0c8ca24b0dfe983f78a04f7\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming02\", \"agency\": \"agency02\", \"caHash\": \"caHash02\" }, \"040be9f1ad6053103cd185995a34e92047eeeccfdeec6db7106d365f35603178ecf3e15e9a69cfbff9c950097fd7acf5190cc03cd7983261ac7f70fa82ca48ff93\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming03\", \"agency\": \"agency03\", \"caHash\": \"caHash03\" } } Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:22:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/configuration.html":{"url":"installation-manual/tianxaun-chain/configuration.html","title":"配置说明","keywords":"","body":"配置说明 概述 天玄节点应用中，每个节点包含一个主配置 thanos-chain.conf ，日志管理配置 logback.xml ，创世块配置 genesis.json 以及节点身份配置 nodeInfo.properties 。 thanos-chain.conf：主配置文件。包括节点网络配置、共识配置、账本配置文件路径、SSL 密钥库配置、密码算法等信息。 logback.xml：日志管理配置文件。包括日志存放路径、日志生成规则等。 genesis.json：创世块配置文件。包括组网节点身份信息、创世区块相关信息等。 nodeInfo.properties：节点身份配置文件。包括本节点的名称、所属机构、节点私钥、节点 ID 等。 主配置文件 thanos-chain.conf thanos-chain.conf 主要包括了 network 、concesus 、resource 、tls 等配置项。配置内容示例如下： network { peer.rpc.ip = 127.0.0.1 peer.bind.ip = 0.0.0.0 peer.listen.discoveryPort = 30303 peer.listen.rpcPort = 9080 peer.channel.read.timeout = 60 peer.discovery = { # List of the seed peers to start # the search for online peers ip.list = [ \"127.0.0.1:30304\" ] } // need consistency pattern of each node transferDataEncrypt = 1 // default false epollSupport = false nettyPoolByteBuf = false gateway { localListenAddress = 7580 remoteServiceAddress = \"127.0.0.1:7180\" pushTxsQueueSize = 6 } } consensus { // 1 = MultipleOrderedProposers; // 2 = RotatingProposer; proposerType = 2 contiguousRounds = 1 maxPackSize = 50000 maxCommitEventNumInMemory = 100 maxPrunedEventsInMemory = 4 // reimportUnCommitEvent = true poolLimit = 3000 roundTimeoutBaseMS = 5000 parallelProcessorNum = 8 } state { checkTimeoutMS = 1500 maxCommitBlockInMemory = 5 } resource { database { needEncrypt = false encryptAlg = AES # place to save physical livenessStorage files # must use absolute path dir = \"/root/thanos-chain/node0/database\" } logConfigPath = \"/root/thanos-chain/node0/resource/chain-logback.xml\" } vm.structured { trace = false dir = vmtrace initStorageLimit = 10000 } #tls settings, such as path of keystore,truststore,etc tls { keyPath = \"/root/thanos-chain/node1/resource/tls/node.key\" certsPath = \"/root/thanos-chain/node1/resource/tls/chain.crt\" } 配置 network peer.rpc.ip：节点的 rpc 地址，用于和其他节点通信。通常填本机的外网或内网地址。 peer.bind.ip：节点绑定的 ip 地址，通常固定为 0.0.0.0 。 peer.listen.discoveryPort：节点监听的 p2p 端口号，主要用于收发【节点发现】消息（底层 udp 协议实现）。 peer.listen.rpcPort：节点监听的 rpc 端口号，主要用于收发【共识】消息（底层 tcp 协议实现）。 peer.channel.read.timeout：节点间通道超时时间。 peer.discovery.ip.list：待连接节点的 ip 列表。 transferDataEncrypt：channel 通信是否加密，全节点统一。 epollSupport：是否启用 EpollEventLoopGroup 实现 JavaNIO 。默认为 false ，表示不启动。当 linux 系统支持 epoll 模式时，可将该项置为 true ，提高性能。 nettyPoolByteBuf：底层通讯字节是否池化，建议为 true 。 gateway.localListenAddress：链节点用于监听链网关发送交易的端口。 gateway.remoteServiceAddress：与该链节点交互的链网关的 ip 地址和端口号。 gateway.pushTxsQueueSize：接收 gateway 打包交易个数的队列大小，建议为 16 。 配置 consensus proposerType: 提案类型，目前仅支持轮循提案，值为 2 。 contiguousRounds：主节点正常共识时连续共识的轮数，超过该轮数需要切换主节点。 maxPackSize：一轮共识中交易最大打包量。 maxCommitEventNumInMemory：内存中最多存储的已共识事件数。 maxPrunedEventsInMemory：内存中最多存储的裁剪事件数。 reimportUnCommitEvent：是否重新共识未共识成功的交易。 poolLimit：交易池交易数量限制。 roundTimeoutBaseMS：Chain BFT 的每轮共识超时基数，建议为 5000 (即 5 秒) 。 parallelProcessorNum：DAG 并行处理交易的 cpu 个数。 配置 state checkTimeoutMS：异步共识的检测超时时间，建议为 1500 (毫秒) 。 maxCommitBlockInMemory：内存中保留已共识成功的 block 数量。 配置 resource database.needEncrypt：账本信息是否需要加密存储。 database.encryptAlg：账本信息加密存储时采用的加密算法。如果无需加密，可忽视该配置项。 database.dir：账本信息存放路径。 logConfigPath：日志管理配置文件 logback.xml 所在路径。 配置 tls keyPath：节点的私钥文件 node.key 所在路径。 certsPath：节点的证书链 chain.crt 所在路径。 日志管理配置文件 chain-logback.xml chain-logback.xml 指定了节点日志的存放位置和生成规则。配置内容示例如下： %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE ./logs/thanos-chain.log ./logs/thanos-chain-%d{yyyy-MM-dd-'h'HH}.log 720 50GB %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE 0 flush occurs often) --> 100 TRACE 配置打印的日志组件 通过 \\ 标签 指定打印的日志组件。在上述示例文件中，指定了三个日志组件：STDOUT、FILE 、ASYNC 1）STDOUT 日志组件： 采用 ch.qos.logback.core.ConsoleAppender 组件，将日志打印到控制台中。其中， 标签 对日志进行格式化。 2）FILE 日志组件：采用 ch.qos.logback.core.rolling.RollingFileAppender 组件，将日志滚动记录到文件中。其中，\\ 标签指定了日志文件名，\\ 指定了滚动策略。 示例中采用 TimeBasedRollingPolicy 滚动策略，即根据时间进行滚动。其中 \\ 指定了滚动日志文件名，\\ 控制保留的日志文件最大数量。 3）ASYNC 日志组件： 采用 ch.qos.logback.classic.AsyncAppender 组件，负责异步记录日志。该组件仅充当事件分派器，必须搭配其他 appender 使用，示例文件中搭配 FILE 日志组件，表示将日志事件异步记录到文件中。 此外，可通过 \\ 标签，指定日志的打印等级。并通过 \\ 标签指定生效的日志组件。 配置打印的日志等级 通过 \\ 标签 指定相应类的日志等级。 创世块配置文件 genesis.json genesis.json 主要包括了 validatorVerifiers ，alloc 以及和创世区块相关配置。配置内容示例如下： { \"validatorVerifiers\": { \"302a300506032b65700321001537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming\", \"agency\": \"agency01\", \"caHash\": \"caHash01\" }, \"302a300506032b6570032100d767bd96e2dd0d3807bf87fb3a09bcef1db36d8313dffdc801e19efa6d6dc7f0\": { \"consensusVotingPower\": 1, \"shardingNum\": 1, \"name\": \"xiaoming01\", \"agency\": \"agency02\", \"caHash\": \"caHash02\" } }, \"committeeAddrs\": [], \"operationsStaffAddrs\": [], \"voteThreshold\": \"2/3\", \"alloc\": { \"5db10750e8caff27f906b41c71b3471057dd2004\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" }, \"31e2e1ed11951c7091dfba62cd4b7145e947219c\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" }, \"ee0250c19ad59305b2bdb61f34b45b72fe37154f\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\" } }, \"maxShardingNum\": 1024, \"shardingNum\": 0, \"nonce\": \"0x0000000000000000\", \"difficulty\": \"0x100000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x1000000000\", \"startEventNumber\": \"12\" } 配置 validatorVerifiers validatorVerifiers 包括了组网节点的身份信息，k-v 对形式。key 是组网节点的公钥字符串，value 包括以下字段： consensusVotingPower：节点的共识投票权重。 shardingNum：节点所处分片。目前可忽略。 name：节点名称。 agency：节点所属机构。 caHash：节点证书序列号。目前可忽略。 配置 committeeAddrs committeeAddrs 包括了管理链的节点的委员会的公钥信息。 配置 operationsStaffAddrs operationsStaffAddrs 包括了链操作者白名单。 配置 voteThreshold 委员会决策的门阀值。 配置 alloc alloc 包括了创世区块的合约状态。目前可忽略。 配置创世块相关信息 maxShardingNum：分片最大数量。 shardingNum：本节点所属分片。 nonce：创世块的 nonce 值。 difficulty：创世块的计算难度 (目前可忽略) 。 mixhash：创世块的混合 hash (目前可忽略)。 coinbase：创世块的 coinbase (目前可忽略) 。 timestamp：创世块的时间戳。 parentHash：创世块的父区块 hash 。 extraData：创世块的附加数据 (目前可忽略) 。 gasLimit：交易执行消耗的最大 gas 值。 startEventNumber：初始块高。 节点身份配置文件 nodeInfo.properties nodeInfo.properties 主要包括了节点身份信息。配置内容示例如下： #ed25519 name=xiaoming agency=agency01 caHash=caHash01 nodeIdPrivateKey=e82aa7abc528720865d6ff2f19175305dd75c9943602e266957bff1eecf10b1b nodeId=1537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d1537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d #publicKey=302a300506032b65700321001537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d #Encrypt/Decrypt #AES nodeEncryptKey=c9ec17b81d5abf18b979693faacbf917 #SM4 #nodeEncryptKey=a77ce8a55dbc209f052d6be716963ec2 name：节点信息。 agency：节点所属结构。 caHash：节点证书序列号 (目前可忽略) 。 nodeIdPrivateKey：节点私钥字符串 (16 进制) 。 nodeId：节点 Id 字符串。 nodeEncryptKey：账本信息加密存储时采用的加密私钥，需要与 database.encryptAlg 配置项指定的加密算法一致 (如果无需加密，可忽视该配置项) 。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/cert.html":{"url":"installation-manual/tianxaun-chain/cert.html","title":"证书说明","keywords":"","body":"证书说明 概述 天玄采用面向 CA 的节点准入机制，支持任意多级的证书结构，保障信息保密性、认证性、完整性、不可抵赖性。 天玄使用 x509 协议的证书格式，根据现有业务场景，默认采用三级的证书结构，自上而下分别为链证书、机构证书、节点证书。 每条链拥有一个链证书及对应的链私钥，链私钥由联盟链委员会共同管理。联盟链委员会可以根据机构的证书请求文件，使用链私钥签发机构证书。 机构私钥由机构管理员持有，可以对机构下属节点签发节点证书。 节点证书是节点身份的凭证，用于与其他持有合法证书的节点间建立 SSL 连接，并进行加密通讯。 天玄节点运行时的文件后缀介绍如下： .key 私钥文件 .crt 证书文件 .csr 证书请求文件 角色定义 天玄证书结构中，共有三种角色，分别是联盟链委员会管理员、机构、节点。 1）联盟链委员会 联盟链委员会负责管理链私钥，并根据机构的证书请求文件，为机构颁发机构证书。 联盟链委员会管理文件如下： ca.crt # 链证书 ca.key # 链私钥 注意：节点建立 TLS 链接时，只有拥有相同链证书 ca.crt 的节点才可建立连接。 2）机构 机构管理员管理机构私钥，可以颁发节点证书。 机构管理员管理文件如下： ca.crt #链证书 agency.crt #机构证书 agency.csr #机构证书请求文件 agency.key #机构私钥 3）节点 节点保存链证书、机构证书、节点证书和私钥，用于建立节点间 TLS 链接。 ca.crt #链证书 agency.crt #机构证书 node.crt #节点证书 node.csr #节点证书请求文件 node.key #节点私钥 chain.crt #链式证书文件，由 ca.crt agency.crt node.crt 合并而成 证书生成流程 注意：需要安装好 GmSSL-v2 ，可参考 GmSSL-v2 安装 证书生成流程如下 1）生成链证书 联盟链委员会使用 openssl 命令请求链私钥 ca.key ，根据 ca.key 生成链证书 ca.crt 。 非国密 # 生成根ca的私钥ca.key与自签名证书ca.crt gmssl genrsa -out ca.key 2048 gmssl req -new -x509 -days 3650 -key ca.key -out ca.crt 国密 # 生成根ca的私钥ca.key与自签名证书ca.crt gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out ca.key gmssl req -new -x509 -days 365 -key ca.key -sm3 -out ca.crt 2）生成机构证书 机构管理员使用 openssl 命令生成机构私钥 agency.key ，然后生成机构证书请求文件 agency.csr 并发送给联盟链委员会。联盟链委员会使用链私钥 ca.key ，根据得到机构证书请求文件 agency.csr 生成机构证书 agency.crt ，并将机构证书发送给对应机构管理员。 非国密 # 生成机构私钥agency.key与证书agency.crt (由根ca签发) gmssl genrsa -out agency.key 2048 gmssl req -new -key agency.key -config cert.cnf -out agency.csr gmssl x509 -req -days 3650 -CA ca.crt -CAkey ca.key -CAcreateserial -in agency.csr -out agency.crt -extensions v4_req -extfile cert.cnf 国密 # 生成机构私钥agency.key与证书agency.crt (由根ca签发) gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out agency.key gmssl req -new -sm3 -key agency.key -config cert.cnf -out agency.csr gmssl x509 -req -days 3650 -CA ca.crt -CAkey ca.key -in agency.csr -out agency.crt -CAcreateserial -sm3 -extensions v4_req -extfile cert.cnf 配置文件 cert.cnf 的内容格式如下： [ca] default_ca=default_ca //默认CA在[default_ca]段配置 [default_ca] default_days = 365 //证书的默认有效期 default_md = sha256 //默认使用的摘要算法 [req] distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] countryName = CN countryName_default = CN //国家名称默认值 stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = ZheJiang //省份默认值 localityName = Locality Name (eg, city) localityName_default = HangZhou //城市默认值 organizationalUnitName = Organizational Unit Name (eg, section) organizationalUnitName_default = netease //机构所属单位默认值 commonName = Organizational commonName (eg, netease) commonName_default = netease //机构名称默认值 commonName_max = 64 [ v3_req ] # Extensions to add to a certificate request basicConstraints = CA:FALSE //指明证书非CA证书 keyUsage = nonRepudiation, digitalSignature, keyEncipherment //指明密钥使用场景，包括加密和签名等 [ v4_req ] basicConstraints = CA:TRUE //指明证书是CA证书 3）生成节点证书 节点生成私钥 node.key 和证书请求文件 node.csr 。而后机构管理员使用私钥 agency.key 为证书请求文件 node.csr 颁发证书。 非国密 # 1.生成节点私钥和节点证书 gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:secp256k1 -out node.key gmssl req -new -key node.key -config cert.cnf -out node.csr gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -extensions v3_req -extfile cert.cnf gmssl x509 -text -in node.crt | sed -n '5p' | sed 's/://g' | tr \"\\n\" \" \" | sed 's/ //g' | sed 's/[a-z]/\\u&/g' | cat >node.serial 国密 # 1.生成节点私钥和节点证书 gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -out node.key gmssl req -new -sm3 -key node.key -config cert.cnf -out node.csr gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -sm3 -extensions v3_req -extfile cert.cnf gmssl x509 -text -in node.crt | sed -n '5p' | sed 's/://g' | tr \"\\n\" \" \" | sed 's/ //g' | sed 's/[a-z]/\\u&/g' | cat >node.serial 而后将多级证书合并成证书链文件 chain.crt (国密/非国密通用步骤) 。 # 2. 生成证书链文件 cat ca.crt agency.crt node.crt > chain.crt 4）生成节点密钥库文件 由于 Java 建立 tls 链接需要读取 keystore 和 truststore 文件 (也可设置为不需要密钥)。因此，需要将节点私钥、节点/机构/链证书 转换成 jks 文件。 # 导出keystore文件 # step1: 合并证书链至chain.crt文件 cat ca.crt agency.crt node.crt > chain.crt # step2: 生成包含节点私钥和证书的pkcs12证书 node.p12 openssl pkcs12 -export -in node.crt -inkey node.key -out node.p12 -passout pass:123456 -name node_key # step3: 将pkcs12证书转换成jks文件keystore.jks keytool -importkeystore -v -srckeystore node.p12 -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore keystore.jks -deststoretype jks -deststorepass 123456 # step4：向keystore中添加证书链 keytool -keystore keystore.jks -importcert -alias node_key -storepass 123456 -file chain.crt # 导出truststore文件 keytool -keystore truststore.jks -importcert -storepass 123456 -file ca.crt 节点证书续期操作 当证书过期时，需要用户使用当前节点私钥重新申请证书，操作如下： 1）节点将node.csr发送给所属机构，机构管理者使用机构私钥重新签发节点证书 非国密 gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -extensions v3_req -extfile cert.cnf 国密 gmssl x509 -req -days 3650 -in node.csr -CAkey agency.key -CA agency.crt -out node.crt -CAcreateserial -sm3 -extensions v3_req -extfile cert.cnf 2）节点收到更新后的节点证书，更新本地密钥文件 # 合并证书链至 chain.crt 文件 cat ca.crt agency.crt node.crt > chain.crt 3）将生成的节点密钥库文件添加至节点对应目录下，如 node0 的 ~/thanos-chain/node0/resource/tls 目录 三级证书续期流程 当整条链的证书均已过期时，需要重新对整条链的证书进行续期操作，续期证书的OpenSSL命令与证书生成流程基本相同，简要步骤如下： 1）使用链私钥 ca.key 重新签发链证书 ca.crt 2）使用链私钥 ca.key 和链证书 ca.crt 对机构证书请求文件 agency.csr 签发得到机构证书 agency.crt 3）使用机构私钥 agency.key 和机构证书 agency.crt 对证书请求文件 node.csr 签发得到节点证书 node.crt 4）使用新生成的节点私钥 node.key 以及 节点证书、机构证书和链证书组成证书链文件 chain.crt ，并替换节点 /resource/tls 目录下的旧文件。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:22:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-chain/log.html":{"url":"installation-manual/tianxaun-chain/log.html","title":"日志说明","keywords":"","body":"日志说明 概述 天玄节点的所有日志都输出到 logs 目录下 thanos-chain-%d{yyyy-MM-dd-'h'HH}.log 的文件中，且定制了日志格式，方便用户通过日志查看链运行状态。日志配置说明请参考：日志管理配置文件。 日志格式 每一条日志记录格式如下： # 日志格式： time log_level [module_name] content # 日志示例： 10:00:38.857 DEBUG [network] addActiveChannel channel:PeerChannel{remotePeer=[ip=127.0.0.1 port=8888 shardingNum=0 nodeId=1537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d1537a67922d21fb10681456efad62578e5f26328ac94a3e9136c68f5aa7a777d]} 各字段含义如下： time: 日志输出时间，精确到纳秒 log_level: 日志级别，目前主要包括 trace , debug , info , warning , error 和 fatal ，其中在发生极其严重错误时会输出 fatal module_name：模块关键字，如网络模块关键字为 network，共识模块关键字为 consensus content：日志记录内容 日志模块关键字 thanos-chain 日志中核心模块关键字如下： 模块 关键字 通用模块 general 通用执行模块 execute 节点发现模块 discover 网络模块 network 线程模型 thanos-worker 第二层同步模块 sync-layer2 状态模块 state 数据库模块 db 序列化模块 rlp 区块/交易同步模块 sync 共识模块 consensus 交易池 txpool 主函数执行 main EVM执行器 VM Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:22:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-gateway/":{"url":"installation-manual/tianxaun-gateway/","title":"天玄网关","keywords":"","body":"天玄节点网关 天玄链节点分为应用和网关两部分，本章节会详细讲解如何手动部署天玄网关： 安装 配置说明 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-gateway/installation.html":{"url":"installation-manual/tianxaun-gateway/installation.html","title":"安装","keywords":"","body":"安装 硬件要求 配置 最低配置 推荐配置 CPU 1.5GHz 2.4GHz 内存 2GB 4GB 核心数 2核 4核 网络带宽 1Mb 5Mb 操作系统 CentOS (7及以上 64位) 或 Ubuntu(18.04 64位) JAVA JDK 1.8 天玄网关安装 前置准备 1）在安装节点网关之前，请确保已经安装并运行了节点应用 2）网关安装所需依赖 Oracle JDK - 1.8 Maven - 3.3.9 Git 3）创建操作目录 创建网关部署操作的目录，以 node0 为例： cd ~ && mkdir -p thanos-gateway/node0 && cd thanos-gateway/node0 在节点目录下创建 database ，logs 和 resource 子目录。其中，logs 目录用于存放链执行日志。resource 目录用于存放网关的配置文件。 mkdir logs resource 在 resource 目录下创建 tls目录，用于存放证书相关文件。 mkdir resource/tls 4）添加可执行文件 获取可执行文件 thanos-gateway.jar ，获取方式见：获取可执行文件。 将 thanos-gateway.jar 放在操作目录下，如 ~/thanos-gateway/node0/ 。 节点网关系统配置 以 node0 节点为例，进行网关系统的配置，包括网络端口配置、tls配置、日志配置等。配置文件中各配置项的具体含义参见：网关配置说明 1）在 ~/thanos-gateway/node0/resource/ 目录下 添加网关的总配置文件 thanos-gateway.conf 和日志管理配置 gateway-logback.xml 。 thanos-gateway.conf 内容模板如下。 gateway { #本机节点信息，用于与其他gateway节点互连 node.myself = \"1:101.35.234.159:100\" rpc { #本机rpc服务ip和端口，用于向sdk提供rpc服务。 address = \"127.0.0.1:8180\" acceptCount = 300 maxThreads = 400 readWriteTimeout = 60000 } http { #本机http服务端口号，用于向sdk提供http服务。 port = 8580 acceptCount = 300 maxThreads = 400 readWriteTimeout = 12000 } #广播节点列表 # broadcast = [\"2:10.246.199.210:200\"] broadcast =[] push { #推送地址 address = \"101.35.234.159:7580\" } sync { #同步出块地址 address = 7180 cache { blockLimit = 10 txPoolDSCacheSizeLimit = 2000 } } switch { #是否仅广播全局节点事件 only.broadcast.globalEvent = 0 } log { logConfigPath = \"/root/thanos-gateway/node0/resource/gateway-logback.xml\" } } #tls settings, such as path of keystore,truststore,etc tls { #与web3j的通信方式，是否使用tls加密 needTLS = false keyPath=\"/root/thanos-gateway/node0/resource/tls/node.key\" certsPath=\"/root/thanos-gateway/node0/resource/tls/chain.crt\" } 当前教程配置单节点天玄链网关，模板中需要修改的配置如下： gateway . rpc . address 需要将 Ip 修改为服务器的内网 Ip 地址。 gateway . log . logConfigPath 需要修改为相应的 gateway-logback.xml 文件的路劲。注意，涉及路径的配置项必须是绝对路径。 gateway-logback.xml 内容如下： UTF-8 %d %-4relative [%thread] %-5level %logger{36} - %msg%n logs/thanos-gateway.log logs/thanos-gateway.log.%d{yyyy-MM-dd}.%i 14 500MB 15GB [%d{yyyy-MM-dd HH:mm:ss}] [%thread] %level %logger{35} [T:%X{trans}] %msg%n 而后，添加 tls 相关证书和密钥等文件。 由于节点网关和节点应用是一一对应的，需要将应用部署中生成的 tls 配置（在 ~/thanos-chain/node0/resource/tls 目录下的 node.key 和 chain.crt 两个文件）添加至 ~/thanos-gateway/node0/resource/tls 目录下。 # 复制文件到指定目录 cp ~/thanos-chain/node0/resource/tls/node.key ~/thanos-gateway/node0/resource/tls/ cp ~/thanos-chain/node0/resource/tls/chain.crt ~/thanos-gateway/node0/resource/tls/ 至此，网关配置完成，可以启动。启动方法为：在网关操作目录 ~/thanos-gateway/node0/ 下，运行如下指令启动节点： java -Xmx256m -Xms256m -Xmn256m -Xss4M -jar thanos-gateway.jar Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"installation-manual/tianxaun-gateway/configuration.html":{"url":"installation-manual/tianxaun-gateway/configuration.html","title":"配置说明","keywords":"","body":"配置说明 概述 节点网关的配置文件中，主要包含一个主配置 thanos-gateway.conf 和日志管理配置 logback.xml 。 主配置文件 thanos-chain.conf thanos-gateway.conf 主要包括了 gateway 和 tls 等配置项。配置内容示例如下： gateway { #本机节点信息，用于与其他gateway节点互连 node.myself = \"1:10.246.199.210:100\" rpc { #本机rpc服务ip和端口，用于向sdk提供rpc服务。 address = \"10.246.199.210:8180\" acceptCount = 300 maxThreads = 400 readWriteTimeout = 60000 } http { #本机http服务端口号，用于向sdk提供http服务。 port = 8580 acceptCount = 300 maxThreads = 400 readWriteTimeout = 12000 } #广播节点列表 # broadcast = [\"2:10.246.199.210:200\"] broadcast =[] push { #推送地址 address = \"10.246.197.244:7580\" } sync { #同步出块地址 address = 7180 cache { blockLimit = 10 txPoolDSCacheSizeLimit = 2000 } } switch { #是否仅广播全局节点事件 only.broadcast.globalEvent = 0 } log { logConfigPath = \"/root/thanos-gateway/node0/resource/gateway-logback.xml\" } } #tls settings, such as path of keystore,truststore,etc tls { #与web3j的通信方式，是否使用tls加密 needTLS = false keyPath=\"/root/thanos-gateway/node1/resource/tls/node.key\" certsPath=\"/root/thanos-gateway/node1/resource/tls/chain.crt\" } 配置 gateway 标签 node.myself：本机节点信息，用于与其他 gateway 节点互连。 rpc.address：本机 rpc 服务 ip 和端口，用于向 sdk 提供 rpc 服务，需要注意此 ip 地址需要使用内网地址，因为当前限制 rpc 只能通过内网访问。 rpc.acceptCount：本机 rpc 服务最多接收的连接数 rpc.maxThreads：本机 rpc 服务最多开启的线程数 rpc.readWriteTimeout：rpc 连接的读写超时时间 (毫秒) 。 http.address：本机 http 服务 ip 和端口，用于向 sdk 提供 rpc 服务。 http.acceptCount：本机 http 服务最多接收的连接数。 http.maxThreads：本机 http 服务最多开启的线程数。 http.readWriteTimeout：http 连接的读写超时时间 (毫秒) 。 broadcast：广播节点列表，即其他 gateway 节点信息。 push.address：gateway 节点推送交易给 chain 应用时，chain 应用的接收地址。 sync.address：gateway 节点的端口号，负责监听 chain 应用推送的区块信息。 sync.cache.blockLimit：缓存的的区块最大数量。 sync.cache.txPoolDSCacheSizeLimit：缓存的交易池大小。 switch.only.broadcast.globalEvent：是否仅广播全局节点事件。 配置 tls 标签 needTLS: gateway 与 web3j 之间通信，是否要开启 tls 认证。 keyPath：节点私钥文件路径。 certsPath：节点证书链文件路径。 日志管理配置文件 gateway-logback.xml gateway-logback.xml指定了节点日志的存放位置和生成规则。配置内容示例如下： %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE ./logs/thanos-gateway.log ./logs/thanos-gateway-%d{yyyy-MM-dd-'h'HH}.log 720 50GB %d{HH:mm:ss.SSS} %p [%c{1}] %m%n TRACE 0 flush occurs often) --> 100 TRACE 配置打印的日志组件 通过 \\ 标签 指定打印的日志组件。在上述示例文件中，指定了三个日志组件：STDOUT 、FILE 、ASYNC 1）STDOUT 日志组件： 采用 ch.qos.logback.core.ConsoleAppender 组件，将日志打印到控制台中。其中，\\ 标签 对日志进行格式化。 2）FILE 日志组件：采用 ch.qos.logback.core.rolling.RollingFileAppender 组件，将日志滚动记录到文件中。其中，\\ 标签指定了日志文件名，\\ 定了滚动策略。示例中采用 TimeBasedRollingPolicy 滚动策略，即根据时间进行滚动。其中 \\ 指定了滚动日志文件名，\\ 控制保留的日志文件最大数量。 3）ASYNC 日志组件： 采用 ch.qos.logback.classic.AsyncAppender 组件，负责异步记录日志。该组件仅充当事件分派器，必须搭配其他 appender 使用，示例文件中搭配 FILE 日志组件，表示将日志事件异步记录到文件中。 此外，可通过 \\ 标签，指定日志的打印等级。并通过 \\ 标签指定生效的日志组件。 配置打印的日志等级 通过 \\ 标签指定相应类的日志等级。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/account.html":{"url":"app-development-manual/account.html","title":"创建和使用账户","keywords":"","body":"创建和使用账户 生成账户 下面是使用 Java SDK 创建一个随机账户的方法，总共支持三种加密算法 1）ECDSA SecureKey secureKey = SecureKey.getInstance(\"ECDSA\", 1); Credentials credentials = Credentials.create(secureKey); 2）SM SecureKey secureKey = SecureKey.getInstance(\"SM\", 1); Credentials credentials = Credentials.create(secureKey); 3）ED25519 SecureKey secureKey = SecureKey.getInstance(\"ED25519\", 1); Credentials credentials = Credentials.create(secureKey); 具体使用哪一种需要跟 sdk 配置保持一致，具体见 thanos-web3j.conf： crypto { #JCA cryptoprovider name. providerName=\"SC\" #JCA sign Algorithm,such as ECDSA, ED25519 etc sign.algorithm=\"ECDSA\" #sign.algorithm=\"ED25519\" #sign.algorithm=\"SM\" #Used for create JCA MessageDigest hash.alg256=\"ETH-KECCAK-256\" hash.alg256=\"ETH-KECCAK-256-LIGHT\" hash.alg512=\"ETH-KECCAK-512\" } 使用指定私钥创建账户的方式如下，以 ECDSA 为例 // SecureKey.fromPrivate(privateKeyBytes); SecureKey secureKey = SecureKey.fromPrivate(Hex.decode(\"010001308f761b30da0baa33457550420bb8938d040a0c6f0582d9351fd5cead86ff12\")); Credentials credentials = Credentials.create(secureKey); 获取账户地址的方式如下 String accountAddr = credentials.getAddress(); 账户地址的计算 账户地址由 ECDSA 公钥计算得来，与以太坊兼容，对 ECDSA 公钥的 16 进制表示计算 keccak-256sum 哈希，取计算结果的后 20 字节的 16 进制表示作为账户地址，每个字节需要两个 16 进制数表示，所以账户地址长度为 40 。 1）生成ECDSA私钥 首先，我们使用 OpenSSL 生成椭圆曲线私钥，椭圆曲线的参数使用 secp256k1 。执行下面的命令，生成 PEM 格式的私钥并保存在 ·ecprivkey.pem· 文件中。 openssl ecparam -name secp256k1 -genkey -noout -out ecprivkey.pem 执行下面的指令，查看文件内容。 cat ecprivkey.pem 可以看到类似下面的输出: -----BEGIN EC PRIVATE KEY----- MHQCAQEEINHaCmLhw9S9+vD0IOSUd9IhHO9bBVJXTbbBeTyFNvesoAcGBSuBBAAK oUQDQgAEjSUbQAZn4tzHnsbeahQ2J0AeMu0iNOxpdpyPo3j9Diq3qdljrv07wvjx zOzLpUNRcJCC5hnU500MD+4+Zxc8zQ== -----END EC PRIVATE KEY----- 接下来根据额私钥计算公钥，执行下面指令 openssl ec -in ecprivkey.pem -text -noout 2>/dev/null| sed -n '7,11p' | tr -d \": \\n\" | awk '{print substr($0,3);}' 可以得到类似下面的输出： 8d251b400667e2dcc79ec6de6a143627401e32ed2234ec69769c8fa378fd0e2ab7a9d963aefd3bc2f8f1cceccba54351709082e619d4e74d0c0fee3e67173ccd 2）根据公钥计算地址 本节我们根据公钥计算对应的账户地址。我们需要获取 keccak-256sum 工具，可以从这里下载。 openssl ec -in ecprivkey.pem -text -noout 2>/dev/null| sed -n '7,11p' | tr -d \": \\n\" | awk '{print substr($0,3);}' | ./keccak-256sum -x -l | tr -d ' -' | tail -c 41 得到类似下面的输出，就是计算得出的账户地址。 dcc703c0e500b653ca82273b7bfad8045d85a470 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/smart-contract.html":{"url":"app-development-manual/smart-contract.html","title":"智能合约","keywords":"","body":"智能合约 天玄目前支持 Solidity 合约 Solidity 合约与以太坊相同，目前支持的版本为 v0.4.25 相关语法学习，请参考：Solidity 官方文档 Remix 在线IDE 下面是编写一个简单的 Erc20 代币合约的示例 1）合约接口 pragma solidity ^0.4.24; interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address who) external view returns (uint256); function allowance(address owner, address spender) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } 2）工具合约 pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // Solidity only automatically asserts when dividing by 0 require(b > 0); uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b = a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 3）合约实现 /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol * * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for * all accounts just by listening to said events. Note that this isn't required by the specification, and other * compliant implementations may not do it. */ contract ERC20 is IERC20 { using SafeMath for uint256; mapping (address => uint256) private _balances; mapping (address => mapping (address => uint256)) private _allowed; uint256 private _totalSupply; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return _totalSupply; } /** * @dev Gets the balance of the specified address. * @param owner The address to query the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address owner) public view returns (uint256) { return _balances[owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param owner address The address which owns the funds. * @param spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address owner, address spender) public view returns (uint256) { return _allowed[owner][spender]; } /** * @dev Transfer token for a specified address * @param to The address to transfer to. * @param value The amount to be transferred. */ function transfer(address to, uint256 value) public returns (bool) { _transfer(msg.sender, to, value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param spender The address which will spend the funds. * @param value The amount of tokens to be spent. */ function approve(address spender, uint256 value) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; } /** * @dev Transfer tokens from one address to another. * Note that while this function emits an Approval event, this is not required as per the specification, * and other compliant implementations may not emit the event. * @param from address The address which you want to send tokens from * @param to address The address which you want to transfer to * @param value uint256 the amount of tokens to be transferred */ function transferFrom(address from, address to, uint256 value) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); emit Approval(from, msg.sender, _allowed[from][msg.sender]); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed_[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * Emits an Approval event. * @param spender The address which will spend the funds. * @param addedValue The amount of tokens to increase the allowance by. */ function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed_[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * Emits an Approval event. * @param spender The address which will spend the funds. * @param subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { require(spender != address(0)); _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue); emit Approval(msg.sender, spender, _allowed[msg.sender][spender]); return true; } /** * @dev Transfer token for a specified addresses * @param from The address to transfer from. * @param to The address to transfer to. * @param value The amount to be transferred. */ function _transfer(address from, address to, uint256 value) internal { require(to != address(0)); _balances[from] = _balances[from].sub(value); _balances[to] = _balances[to].add(value); emit Transfer(from, to, value); } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param account The account that will receive the created tokens. * @param value The amount that will be created. */ function _mint(address account, uint256 value) internal { require(account != address(0)); _totalSupply = _totalSupply.add(value); _balances[account] = _balances[account].add(value); emit Transfer(address(0), account, value); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param account The account whose tokens will be burnt. * @param value The amount that will be burnt. */ function _burn(address account, uint256 value) internal { require(account != address(0)); _totalSupply = _totalSupply.sub(value); _balances[account] = _balances[account].sub(value); emit Transfer(account, address(0), value); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal burn function. * Emits an Approval event (reflecting the reduced allowance). * @param account The account whose tokens will be burnt. * @param value The amount that will be burnt. */ function _burnFrom(address account, uint256 value) internal { _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value); _burn(account, value); emit Approval(account, msg.sender, _allowed[account][msg.sender]); } } /** * @title ERC20Detailed token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract ERC20Detailed is IERC20 { string private _name; string private _symbol; uint8 private _decimals; constructor (string name, string symbol, uint8 decimals) public { _name = name; _symbol = symbol; _decimals = decimals; } /** * @return the name of the token. */ function name() public view returns (string) { return _name; } /** * @return the symbol of the token. */ function symbol() public view returns (string) { return _symbol; } /** * @return the number of decimals of the token. */ function decimals() public view returns (uint8) { return _decimals; } } /** * @title SimpleToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `ERC20` functions. */ contract SimpleToken is ERC20, ERC20Detailed { uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals())); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor () public ERC20Detailed(\"TMDToken\", \"TMD\", 18) { _mint(msg.sender, INITIAL_SUPPLY); } } Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/java-sdk/":{"url":"app-development-manual/java-sdk/","title":"Java SDK","keywords":"","body":"Java SDK 本章节会介绍天玄 Java SDK 相关的教程： 快速入门 SDK配置说明 远程调用接口 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/java-sdk/quick-start.html":{"url":"app-development-manual/java-sdk/quick-start.html","title":"快速入门","keywords":"","body":"快速入门 前置条件 在开始本教程前，请确保已经准备好了以下资源 JDK 1.8： Java 应用需要依赖 oracle jdk1.8 ，且 JDK 版本不低于 1.8.0u201 Maven3.3.9： 项目编译需要依赖 Maven，且版本不低于 3.3.9 bcprov-jdk： 在使用 sdk 时，需要在 java 运行环境中（具体为 $JAVA_HOME（JDK 所在目录）/jre/lib/ext 目录下）添加 bcprov-jdk15on-1.66.jar 包 IDE： 进入IntelliJ IDEA 官网，下载并安装社区版 IntelliJ IDEA 天玄测试链： 请参考 快速搭建天玄网络 搭建，并获取到相应的 http 或者 rpc 链接 智能合约应用： 请准备好需要部署的应用合约（本教程涉及的物料包中也提供了两个简单的智能合约示例） 编译智能合约 目前天玄链支持 solidity 编译及运行最高版本为 0.4.25 ，且必须使用附件提供的 solc 编译工具编译合约 编译智能合约部分教程请使用 Linux 系统进行，推荐 Centos 7+ 或者 Ubuntu 18+ 。 获取相关物料包 需要从 GitHub 上拉取 thanos-web3j 代码，由于 thanos-web3j 编译依赖于 thanos-common.jar ，所以还需要拉取 thanos-common 代码。 git clone https://github.com/TianXuan-Chain/thanos-web3j.git # thanos-web3j代码库 git clone https://github.com/TianXuan-Chain/thanos-common.git # thanos-common代码库 编译 按照依赖顺序，在编译 thanos-common 前，还需将其依赖的 bctls-gm-jdk15on.jar 加载到本地 Maven 仓库当中。 mvn install:install-file -Dfile=bctls-gm-jdk15on.jar -DgroupId=org.bouncycastle -DartifactId=bctls-gm-jdk15on -Dversion=0.1 -Dpackaging=jar 该文件可以从此处获取：https://github.com/TianXuan-Chain/thanos-package-generate/blob/main/dependencies/jar/bctls-gm/bctls-gm-jdk15on.jar 而后，编译 thanos-common 。 cd thanos-common mvn clean install -Dmaven.test.skip=true 编译后，thanos-common.jar 应已被加载到了本地 Maven 仓库当中。可以开始编译 thanos-web3j 了。 请先检查 thanos-web3j 内部文件是否具备可执行权限，如果不具备，可以使用以下指令。 chmod -R 777 thanos-web3j # 赋予目录内文件最高权限 而后运行编译脚本。 cd thanos-web3j ./compile.sh build 编译成功后会在当前目录下产生一个 dist 文件夹，该文件夹结构如下： | 目录 | 说明 | | -------------- | ---------------------------------------- | | dist/apps | web3sdk项目编译生成的jar包web3sdk.jar | | dist/bin | - web3sdk: 可执行脚本，调用web3sdk.jar执行web3sdk内方法(如部署系统合约、调用合约工具方法等) - compile.sh: 调用该脚本可将dist/contracts目录下的合约代码转换成java代码，该功能便于用户基于web3sdk开发更多应用 | | dist/conf | 配置目录, 用于配置节点信息、证书信息、日志目录等，详细信息会在下节叙述 | | dist/contracts | 合约存放目录，调用compile.sh脚本可将存放于该目录下的.sol格式合约代码转换成java代码 | | dist/lib | 存放web3sdk依赖库的jar包 | | dist/solc | 存放合约编译工具,solc需要安装到/usr/local/bin/ | 如果 compile.sh 脚本执行失败，可能是服务器存在网络连接问题或者系统不兼容。可以手动安装 gradle 后进行编译。gradle 安装流程如下： # Linux 系统 # 下载 gradle 文件 wget https://services.gradle.org/distributions/gradle-5.6.2-all.zip -P /software # 解压 sudo unzip -d /software/gradle /software/gradle-5.6.2-all.zip 修改配置，将下面内容写入到 gradle.sh 中。 sudo vim /etc/profile.d/gradle.sh # 将下面下面写入 gradle.sh 中 export GRADLE_HOME=/software/gradle/gradle-5.6.2 export PATH=${GRADLE_HOME}/bin:${PATH} 而后执行脚本 sudo chmod +x /etc/profile.d/gradle.sh source /etc/profile.d/gradle.sh # 验证 gradle 安装 gradle -v 注意：如果第一步拉取 gradle 安装包失败，表明服务器网络连接 gradle 官网存在限制，请到 官方网站 下载后上传到服务器。 gradle 安装完成后，如果是国内服务器，可以看需求是否修改为国内的镜像源。在 {USER_HOME}/.gradle/ 目录下创建 init.gradle 文件，并添加下面内容： allprojects { repositories { def ALIYUN_REPOSITORY_URL = 'https://maven.aliyun.com/repository/public' all { ArtifactRepository repo -> if (repo instanceof MavenArtifactRepository) { def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2')) { project.logger.lifecycle \"Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.\" remove repo } } } maven { url ALIYUN_REPOSITORY_URL } } } 安装配置完后，进入 thanos-web3j 目录，执行以下指令： # 考虑到后续可能会依赖到 thanos-web3j.jar，所以将其发布到本地 Maven 仓库中 gradle publishToMavenLocal # 如果不需要将 thanos-web3j.jar 发布到本地 Maven 仓库 # 可以使用 gradle build 指令 配置 java 运行环境 在使用 Web3j SDK 时，需要在 java 运行环境中（具体为 $JAVA_HOME/jre/lib/ext 目录下）添加 bcprov-jdk15on-1.66.jar 包。该文件可以在此处获取：https://github.com/TianXuan-Chain/thanos-package-generate/blob/main/dependencies/jar/bcprov-jdk15on-1.66.jar 安装 solc 将 dist/solc 目录下的可执行文件 solc 复制到 /user/local/bin/ 目录下。 cd dist cp ./solc/solc /usr/local/bin/ 查看 solc 版本，确认是否安装成功。 solc --version 有版本信息输出，表示安装成功。 编译合约 将需要编译的 solidity 合约代码放置到 dist/contracts 目录内，当前目录下有两个示例合约 HelloWorld.sol 和 TokensDemo.sol 。而后运行 dist/bin/compile.sh 脚本。 ./bin/compile.sh com 执行成功后，会在 dist 文件夹内产生一个 output 文件夹，合约编译后对应的 abi ，bin 以及 java 文件（在 com 文件夹内）都存放在其中。 java 文件是基于 abi 与 bin 文件生成的，其中abi 与以太坊的一致，abi相关知识可以在此处了解：https://docs.soliditylang.org/en/latest/abi-spec.html# 部署并使用合约应用 前置准备 开始本部分教程时，默认用户已经准备好了编译为 Java 的合约应用。 这部分教程使用 IntelliJ IDEA 进行。如果上述流程和编写应用的不是一台机器 (例如：使用 Windows 系统进行)。请参考应用部署示例在当前机器重新构建 Maven 本地依赖。 引入 SDK 使用 Gradle 引入 SDK compile('com.netease.blockchain.thanos:thanos-web3j:1.7.3-SNAPSHOT') 使用 Maven 引入 SDK com.netease.blockchain.thanos thanos-web3j 1.7.3-SNAPSHOT 初始化 SDK 配置 1）通过 new 方法初始化 SystemConfig 该方法使用了 SystemConfig 的 new 方法来初始化系统配置。方法入参说明如下： public SystemConfig( Integer web3Size, //【rpc】 与单个链节点建立的rpc连接数 Integer checkInterval, //【rpc】检查时间间隔，即多久检查一次 sdk与链节点之间的rpc连接是否正常 List gatewayHttpIPList, //【http】链节点 HTTP连接的ip+port列表 List gatewayRpcIPList, //【rpc】链节点 RPC连接的ip+port列表 Boolean needTLS, //【rpc】 rpc连接是否需要建立tls通道 String certsPath, //【rpc】 建立tls通道时，sdk证书文件存放的绝对路径 String keyPath, //【rpc】 建立tls通道时，sdk私钥文件存放的绝对路径 String logConfigPath//【rpc】 日志配置文件存放路径 ) 如果只需要建立 HTTP 连接。 List httpIpPortList = nodeList.stream().map(node -> node.getIp() + \":\" + node.getHttpPort()).collect(Collectors.toList()); SystemConfig systemConfig = new SystemConfig(1, 60, httpIpPortList, new ArrayList<>(), false, null, null, null); 具体用法可参考 thanos-web3j 中的 test.add.AddHttpTest 示例文件。 如果只需要建立 RPC 连接。 List rpcIpPortList= nodeList.stream().map(node -> node.getIp() + \":\" + node.getRPCPort()).collect(Collectors.toList()); SystemConfig systemConfig = new SystemConfig(1, 60, new ArrayList<>(), rpcIpPortList, true, certsPath, keyPath, null); 2）通过配置文件初始化 Web3Manager 使用 SDK 前，需要先生成两个配置文件： 主配置文件 thanos-web3j.conf 日志配置文件 logback.xml 配置文件说明文档详见：thanos-web3j 配置说明。 完整的应用及配置文件的目录相对关系如下： ├── resource │ ├── logback.xml │ ├── thanos-web3j.conf │ └── tls │ ├── chain.crt │ └── sdk.key └── thanos-test.jar(使用sdk的java应用) 首先，配置 thanos-web3j.conf 文件，示例如下： gateway = { # List of gateway peers to send msg rpc.ip.list = [ #\"127.0.0.1:8082\" #\"10.246.199.210:8182\" \"10.246.200.174:8180\",\"10.246.200.174:8181\" ] web3Size = 3 #connection check interval (s) checkInterval = 60 # List of gateway peers http port to send msg http.ip.list = [ #\"127.0.0.1:8082\" \"10.246.200.174:8580\", \"10.246.200.174:8581\" ] } resource { # logConfigPath = \"F:\\\\myJava\\\\blockchain3.0\\\\thanos-web3j\\\\src\\\\main\\\\resources\\\\logback.xml\" } #tls settings, such as path of keystore,truststore,etc tls { needTLS = true keyPath=\"F:\\\\myJava\\\\blockchain3.0\\\\thanos-web3j\\\\src\\\\main\\\\resources\\\\gm-tls\\\\sdk.key\" certsPath=\"F:\\\\myJava\\\\blockchain3.0\\\\thanos-web3j\\\\src\\\\main\\\\resources\\\\gm-tls\\\\chain.crt\" } 根据实际情况，修改如下配置： 日志配置文件所在路径 logConfigPath (要求是绝对路径) 如果应用需要使用链的 http 接口服务（包括合约部署和调用），需要修改配置项 http.ip.list ，对应网关所在机器 ip 和应用的 http 端口 如果应用需要使用链的rpc接口服务（除合约部署和调用外，还有权限管理），需要修改配置项 rpc.ip.list ，对应网关所在机器 ip 和应用的 rpc 端口。并修改 tls 配置项，配置 SDK 密钥文件和链证书文件路径 在业务系统中加载配置并完成 Web3Manager 的初始化。 SystemConfig systemConfig = ConfigResourceUtil.loadSystemConfig(); 初始化链连接器 加载日志路径，并使用 SystemConfig 初始化 Web3manager ConfigResourceUtil.loadLogConfig(systemConfig.logConfigPath()); Web3Manager web3Manager = new Web3Manager(systemConfig); SDK 调用 由于 thanos-web3j 提供了两种链连接方式（rpc 和 http），下面分别介绍每种连接方式的调用逻辑。 1）HTTP接口调用 初始化 Web3j 对象，连接网关节点的 http 接口 Web3j web3j = web3Manager.getHttpWeb3jRandomly(); 部署合约并发起交易，样例给出部署及调用 SimpleToken 合约的用例： SecureKey user = SecureKey.getInstance(\"ECDSA\", 1); //随机生成密钥对 //SecureKey user = SecureKey.fromPrivate(Hex.decode(\"010001308f761b30da0baa33457550420bb8938d040a0c6f0582d9351fd5cead86ff11\"));//根据私钥恢复密钥对 Credentials cred = Credentials.create(user); SimpleToken simpleToken = SimpleToken.deploy(web3j, credentials, BigInteger.valueOf(1), BigInteger.valueOf(3000000), BigInteger.valueOf(0)).get();//部署合约 contractAddress = simpleToken.getContractAddress(); SimpleToken proxy = SimpleToken.load(contractAddress, web3j, credentials, BigInteger.ONE, BigInteger.valueOf(3000000)); ThanosTransactionReceipt receipt = proxy.transfer(new Address(users.get(i).getAddress()), new Uint256(amount)).get();//调用合约 由于 http 版本的 Web3j 对象采用长连接的方式。因此，在 Web3j 使用完成后，需要手动释放连接资源。 finally { web3j.close(); } 2）RPC接口调用 初始化 Web3j 对象，连接网关节点的 rpc 通道。 Web3j web3j = web3Manager.getWeb3jRandomly(); 生成全局事件并发送上链，样例给出添加委员时的用例： Credentials credentials = Credentials.create(sender); RawTransactionManager transactionManager = new RawTransactionManager(web3j, credentials);//生成交易管理器，用于发送交易 //组装全局事件，这里为投票准入委员事件 Long consensusNumber = transactionManager.getThanosLatestConsensusNumber(); Random r = new SecureRandom(); BigInteger randomid = new BigInteger(250, r); byte[] proposalId = randomid.toByteArray(); VoteCommitteeCandidateEvent event = new VoteCommitteeCandidateEvent(0, 0, proposalId, candidateAddr); ThanosGlobalNodeEvent globalNodeEvent = new ThanosGlobalNodeEvent(sender.getPubKey(), randomid.toByteArray(), consensusNumber + 10L, GlobalEventCommand.VOTE_COMMITTEE_CANDIDATE.getCode(), event.getEncoded(), (byte[])null); //发送全局事件上链 EthSendTransaction transaction = transactionManager.sendGlobalNodeEvent(globalNodeEvent); String str = transaction.getTransactionHash(); logger.debug(\"addCommittee txHash:{}\", str); //根据事件hash查询全局事件链上执行的回执，并根据回执判断是否成功。 ThanosGlobalNodeEventReceipt receipt = transactionManager.waitForGlobalNodeEventReceipt(str); if (receipt == null || receipt.getExecutionResult() == null) { logger.warn(\"CommitteeManager voteForAddCommittee receipt is null.\"); return false; } int executeResult = ByteUtil.byteArrayToInt(receipt.getExecutionResult()); if (CandidateEventConstant.VOTE_FAILED == executeResult) { logger.error(\"CommitteeManager voteForAddCommittee failed. receipt:{}\", receipt); } Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:22:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/java-sdk/config.html":{"url":"app-development-manual/java-sdk/config.html","title":"配置说明","keywords":"","body":"配置说明 概述 天玄链中，使用 sdk 需要加载主配置文件 thanos-web3j.conf 以及 日志管理配置 logback.xml。 主配置文件 thanos-web3j.conf thanos-web3j.conf 主要包括了 gateway 、resource 、tls 等配置项。配置内容示例如下： gateway = { # List of gateway peers rpc port to send msg rpc.ip.list = [ \"127.0.0.1:8082\", \"127.0.0.1:8182\" ] web3Size = 3 #connection check interval (s) checkInterval = 60 # List of gateway peers http port to send msg http.ip.list = [ \"127.0.0.1:8581\", \"127.0.0.1:8582\" ] } resource { logConfigPath = \"/root/thanos-test/resource/logback.xml\" } #tls settings, such as path of keystore,truststore,etc tls { needTLS = true keyPath=\"/root/thanos-test/resource/tls/node.key\" certsPath=\"/root/thanos-test/resource/tls/chain.crt\" } 配置gateway标签 rpc.ip.list：gateway 提供 rpc 服务的 ip 和端口号（列表）。 web3Size：每个 gateway 节点对应的 rpc 连接池中的连接数量。 checkInterval：rpc 连接有效性检测的时间间隔。 http.ip.list：gateway 提供 http 服务的 ip和端口号（列表）。 配置resource标签 logConfigPath：日志管理配置文件 logback.xml 所在路径。 配置tls标签 needTLS：与 gateway 之间的 rpc 通信是否需要建立 tls 链接，需要与 gateway 端配置保持一致。 keyPath：sdk 的私钥文件 node.key 所在路径。 certsPath：sdk 的证书链 chain.crt 所在路径。 日志管理配置文件 logback.xml logback.xml 指定了节点日志的存放位置和生成规则。配置内容示例如下： %d{HH:mm:ss.SSS} %p [%c{1}] %m%n DEBUG ./logs/thanos-test.log ./logs/thanos-test-%d{yyyy-MM-dd-'h'HH}.log 720 50GB %d{HH:mm:ss.SSS} %p [%c{1}] %m%n DEBUG 0 flush occurs often) --> 100 --> 配置打印的日志组件 通过 \\ 标签 指定打印的日志组件。在上述示例文件中，指定了三个日志组件：STDOUT 、FILE 、ASYNC 1）STDOUT 日志组件： 采用 ch.qos.logback.core.ConsoleAppender 组件，将日志打印到控制台中。其中，标签 对日志进行格式化。 2）FILE 日志组件：采用 ch.qos.logback.core.rolling.RollingFileAppender 组件，将日志滚动记录到文件中。其中，\\ 标签指定了日志文件名，\\ 指定了滚动策略。示例中采用 TimeBasedRollingPolicy 滚动策略，即根据时间进行滚动。其中 \\ 指定了滚动日志文件名，\\ 控制保留的日志文件最大数量。 3）ASYNC 日志组件： 采用 ch.qos.logback.classic.AsyncAppender 组件，负责异步记录日志。该组件仅充当事件分派器，必须搭配其他 appender 使用，示例文件中搭配 FILE 日志组件，表示将日志事件异步记录到文件中。此外，可通过 \\ 标签，指定日志的打印等级。并通过 \\ 标签指定生效的日志组件。 配置打印的日志等级 通过 \\ 标签 指定相应类的日志等级。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/java-sdk/interface.html":{"url":"app-development-manual/java-sdk/interface.html","title":"远程调用接口","keywords":"","body":"远程调用接口 接口方法调用 按照教程配置好 Web3j 并初始化 Web3Manager 实例后，以 thanosGetLatestBeExecutedNum 为例： Web3j web3j = web3Manager.getHttpWeb3jRandomly(); Long res = web3j.thanosGetLatestBeExecutedNum().send().getNumber(); 更多接口请参考后文。 接口清单 thanosGetLatestBeExecutedNum 获取目前最新被异步执行的区块块高 参数 无 返回值 Long - 区块块高 thanosGetLatestConsensusNumber 获取目前最新被异步共识的区块块高 参数 无 返回值 Long - 区块块高 thanosGetCurrentCommitRound 获取目前最新的共识轮次 参数 无 返回值 Long - 轮次 thanosGetBlockNumber 通过blockNumber获取区块链信息 参数 blockNumber : String - 区块链编号 返回值 string - 区块链信息 thanosGetEthTransactionByHash 通过交易hash获取交易信息，只能获取到网关处缓存中的历史交易 参数 transactionHash : String - 交易hash 返回值 string - 交易信息 thanosGetEthTransactionByHashByChain 通过交易hash获取交易信息，可以获取到全量的历史交易 参数 transactionHash : String - 交易hash 返回值 string - 交易信息 thanosGetEehTransactionsByHashes 通过交易hash批量获取交易信息 参数 transactionHashList : String - 交易hash 返回值 string - 交易信息 thanosGetGlobalNodeEventByHash 通过全局节点事件hash获取事件信息，只能获取到网关处缓存中的历史全局节点事件 参数 eventHash : String - 事件hash 返回值 string - 事件信息 thanosGetGlobalNodeEventByHashByChain 通过交易hash批量获取交易信息，可以获取到全量的历史全局节点事件 参数 transactionHash : String - 交易hash 返回值 string - 交易信息 thanosGetGlobalNodeEventReceiptByHash 通过全局节点事件hash获取事件回执 参数 eventHash : String - 事件hash 返回值 string - 事件回执信息 thanosEthCall 发送交易请求到区块链立即执行，无需共识 参数 rawData : String - rlp序列化后交易 返回值 string - 交易执行回执 thanosSendGlobalNodeEvent 发送全局节点事件请求到区块链执行，返回事件hash 参数 rawData : String - rlp序列化后事件信息 返回值 string - 事件hash thanosSendEthRawTransaction 发送交易请求到区块链执行，返回交易hash 参数 rawData : String - rlp序列化后交易 返回值 string - 交易hash thanosSendEthRawTransactionList 批量发送交易请求到区块链执行，返回交易 hash 列表 参数 rawData : List\\ - rlp序列化后的交易信息列表 返回值 list\\ - 交易 hash 列表 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"app-development-manual/interface-list.html":{"url":"app-development-manual/interface-list.html","title":"天玄链功能接口列表","keywords":"","body":"天玄链功能接口列表 下列接口的示例中采用 curl 命令，curl 是一个利用 url 语法在命令行下运行的数据传输工具，通过 curl 命令发送 http post 请求，可以访问天玄链的 JSON RPC 接口。curl 命令的 url 地址设置为节点配置文件监听端口（gateway.http.port）。为了格式化 json ，使用 json 工具进行格式化显示。 thanos_clientVersion 描述 返回节点的版本信息 参数 无 返回值 string - 版本信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_clientVersion\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"id\": 83, \"jsonrpc\": \"2.0\", \"result\": { \"thanos/v1.0.0/Linux/Java/jdk1.8/1.0.0\" } } thanos_sha3 描述 计算参数的 sha3 的 hash 值，返回为 16 进制 参数 data: string - 元数据 返回值 string - 该元数据的 hash 值(0x开头的十六进制字符串) 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_sha3\",\"params\":[\"0x186a0\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": \"0x77caf3b88c63099c04df97ff5dc5ad40691663664611a522b0ca159436cb6efc\" } thanos_net_version 描述 返回天玄区块链组网版本 参数 无 返回值 string - 天玄区块链组网版本 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_net_version\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": \"1.0.0\" //目前thanos组网版本 } thanos_protocolVersion 描述 返回天玄区块链协议版本 参数 无 返回值 string - 天玄区块链协议版本 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_protocolVersion\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": \"1.0.0\" //目前thanos协议版本 } thanos_getCompilers 描述 返回天玄区块链编译器 参数 无 返回值 string[] - 天玄区块链编译器类型 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getCompilers\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": [ \"solidity\" //目前thanos的evm版本 ] } thanos_sendEthRawTransaction 描述 发送交易请求到区块链执行，返回交易 hash 参数 rawData : string - rlp 序列化后交易 返回值 string - 交易 hash 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_sendEthRawTransaction\",\"params\":[\"0xf9051ea002bf9825d12eb69d5c397d37e2380923181b2a6c7cfa916632b878bbcac3fb0701832dc6c08080b90461608060405234801561001057600080fd5b5060408051808201909152600b8082527f48692c57656c636f6d652100000000000000000000000000000000000000000060209092019182526100559160009161005b565b506100f6565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061009c57805160ff19168380011785556100c9565b828001600101855582156100c9579182015b828111156100c95782518255916020019190600101906100ae565b506100d59291506100d9565b5090565b6100f391905b808211156100d557600081556001016100df565b90565b61035c806101056000396000f3006080604052600436106100615763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416634725721781146100665780634ed3885e1461008d5780636d4ce63c146100e857806380637f6e14610172575b600080fd5b34801561007257600080fd5b5061007b61018a565b60408051918252519081900360200190f35b34801561009957600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526100e69436949293602493928401919081908401838280828437509497506101919650505050505050565b005b3480156100f457600080fd5b506100fd6101d1565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561013757818101518382015260200161011f565b50505050905090810190601f1680156101645780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561017e57600080fd5b506100e6600435610267565b6001545b90565b80516101a4906000906020840190610298565b506040517f15504e11775a2cc1976320e3c666e5965057d329614934f0b707fc711dfb82ec90600090a150565b60008054604080516020601f600260001961010060018816150201909516949094049384018190048102820181019092528281526060939092909183018282801561025d5780601f106102325761010080835404028352916020019161025d565b820191906000526020600020905b81548152906001019060200180831161024057829003601f168201915b5050505050905090565b60018190556040517f15504e11775a2cc1976320e3c666e5965057d329614934f0b707fc711dfb82ec90600090a150565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106102d957805160ff1916838001178555610306565b82800160010185558215610306579182015b828111156103065782518255916020019190600101906102eb565b50610312929150610316565b5090565b61018e91905b80821115610312576000815560010161031c5600a165627a7a723058208e5a4aa7b5e303ce22caabadd228c8c48f4f9bf5e999cba9fcfbcec9096ed44a002986c58468656865b841043973cb86d7bef9c96e5d589601d788370f9e24670dcba0480c0b3b1b0647d13d0f0fffed115dd2d4b5ca1929287839dcd4e77bdc724302b44ae48622a8766ee6b846304402201f497a8224036e6d767e20e7adda8ceaaa62f5f1780101e2d1709b6a873a93a5022034e8559e0b421788dc9f4b1449588c3aaeb6fe7c808a84eec5e4ad1dbeb6627f\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": \"0xb4035c2dfde8b5234011130d554659dd5b16979c2b73e2f6691a90966b832726\" //返回交易hash } thanos_ethCall 描述 发送交易请求到区块链立即执行，无需共识 参数 rawData：string - rlp 序列化后交易 返回值 string - 交易执行回执 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_ethCall\",\"params\":[\"0xf8d89f7d584aedd3309152a4acd24af50b66d0f1a9d0a64b5925d3b0e52b01e506998401c9c3808401c9c380940b0646c1f468c7e5756c8a854ee84b63a8dfe59201846d4ce63c86c58474657374b841043973cb86d7bef9c96e5d589601d788370f9e24670dcba0480c0b3b1b0647d13d0f0fffed115dd2d4b5ca1929287839dcd4e77bdc724302b44ae48622a8766ee6b8473045022100bf66e9305780cf55186973d3b65f7f32f524ec9c09acb77c95e8954fd8e7dd9702205ac6d7aca2b6fafc8fee975daa8f64d0ff97bc7fd30d8c4d58c81a527a1d9470\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //result需要解析后才能查看 \"result\": \"f90134c0f8cb945db10750e8caff27f906b41c71b3471057dd20049f7d584aedd3309152a4acd24af50b66d0f1a9d0a64b5925d3b0e52b01e50699808401c9c3808401c9c380940b0646c1f468c7e5756c8a854ee84b63a8dfe59201846d4ce63cc58474657374b8473045022100bf66e9305780cf55186973d3b65f7f32f524ec9c09acb77c95e8954fd8e7dd9702205ac6d7aca2b6fafc8fee975daa8f64d0ff97bc7fd30d8c4d58c81a527a1d9470a022c35de1f5275fb27d12ee936d8e7e636615d16e125a7b35d1c9ca2f36c3a7fb8202f8b86000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003313030000000000000000000000000000000000000000000000000000000000080\" } thanos_getLatestBeExecutedNum 描述 获取目前最新被异步执行的区块块高 参数 无 返回值 Long - 区块快高 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getLatestBeExecutedNum\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": 53 //返回最新执行块高 } thanos_getLatestConsensusNumber 描述 获取目前最新被异步共识的区块块高 参数 无 返回值 Long - 区块快高 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getLatestConsensusNumber\",\"params\":[],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": 53 //返回最新共识块高 } thanos_getBlockByNumber 描述 通过 blockNumber 获取区块链信息 参数 blockNumber : string - 区块链编号 返回值 string - 区块链信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getBlockByNumber\",\"params\":[\"52\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //result需要解析才能查看数据 \"result\": \"f9031ba03a669ef806525c555be50d1dfd7ec2be439c98175e3506e68c1c5059236e9ac3a0615a2b238bd9d9009f83999dc16198a430967db0e39a2729ac7105e3c452705300a024c810a501e47ed5a3b106234e8523373a124059266ad05f9bea4e0efbb290e3a0e25e105349583bb390dae102d1dd8c274922135255c79230bce3c019361d7ad00234860175d4148cc2c18001f9016cf83af838940b0646c1f468c7e5756c8a854ee84b63a8dfe592e1a015504e11775a2cc1976320e3c666e5965057d329614934f0b707fc711dfb82ec80f90128945db10750e8caff27f906b41c71b3471057dd2004a001a53e8a4ed98800a6b6d914c4c673f9ddd5b1a435a0b5f8ff62fd45ab1dd8603801832dc6c0940b0646c1f468c7e5756c8a854ee84b63a8dfe59280b8644ed3885e000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130300000000000000000000000000000000000000000000000000000000000c58468656865b8473045022100b25b3cca6bf0404472dca9e32e72a77256b460733397e0fc6157f8a2dcfd71f202207a7b3a62e96d968be81d5efdf236484a88cf1a39d5009b90051903d6eed9eb3ca04bf7ad3c4c81b417cf7788e5d2107ea9213a880ca602290648fb5ca7820934288202898080f88bb841040d3a176a1e51f68e04deda9c6437543dcd87db185b970476c611052b106a2422af7c496e09fd7f6215284ed83cb3b66bc24f9a318eded9ec7f6722fc52616e29b846304402201830d020942385e79e2524073fce37d6680e1ce4f94b2d0122009a6504dee7c3022042f410c84597e053f52bc2fd748e13e27a83306c84a14646016a9657ce0a6bd7f88cb841047cbf053e81cc2cd1896fc5470c428cad1432cc53d19976a40fa70cae0e3a4415cc1648fc37dc07b5fef0f2a7da71093a88f308adb0c8ca24b0dfe983f78a04f7b84730450220504ffbc833858072c43a5d7a9d6e9555068956e25bda6695cfc8e9526db55459022100b30b63ace222805c9e328ee07bc7eb76e5038f9738b249265a3553257766553c\" } thanos_getEthTransactionByHash 描述 通过交易 hash 获取交易信息 参数 transactionHash : string - 交易 hash 返回值 string - 交易信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getEthTransactionByHash\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"]}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": \"f9016cf83af8389436ac9fe88d2652c30169d4658eddf0e15a97da3fe1a015504e11775a2cc1976320e3c666e5965057d329614934f0b707fc711dfb82ec80f90128945db10750e8caff27f906b41c71b3471057dd2004a00313f1b08e9917b6c8bf2d77e4ba00d7adcc1bcd3161204f20cd6dd80add92e83b01832dc6c09436ac9fe88d2652c30169d4658eddf0e15a97da3f80b8644ed3885e000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130300000000000000000000000000000000000000000000000000000000000c58468656865b847304502200563ac7a29fedc093f971c23dcdd6b552c812d41308d4d136aa0d1dbfac60a5a022100ee377f570e6daf183c09e820fa534b82232640e20576482cbb71579e3fcaf944a01f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd8202bb8080\" } thanos_getEthTransactionByHashByChain 描述 通过交易hash获取交易信息 参数 transactionHash : String - 交易 hash 返回值 string - 交易信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getEthTransactionByHashByChain\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": \"f9016cf83af8389436ac9fe88d2652c30169d4658eddf0e15a97da3fe1a015504e11775a2cc1976320e3c666e5965057d329614934f0b707fc711dfb82ec80f90128945db10750e8caff27f906b41c71b3471057dd2004a00313f1b08e9917b6c8bf2d77e4ba00d7adcc1bcd3161204f20cd6dd80add92e83b01832dc6c09436ac9fe88d2652c30169d4658eddf0e15a97da3f80b8644ed3885e000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000033130300000000000000000000000000000000000000000000000000000000000c58468656865b847304502200563ac7a29fedc093f971c23dcdd6b552c812d41308d4d136aa0d1dbfac60a5a022100ee377f570e6daf183c09e820fa534b82232640e20576482cbb71579e3fcaf944a01f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd8202bb8080\" } thanos_getEthTransactionsByHashes 描述 通过交易 hash 批量获取交易信息 参数 transactionHashList : string - 交易 hash 返回值 string - 交易信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getEthTransactionByHashByChain\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"]}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": [] } thanos_getGlobalNodeEventByHash 描述 通过全局节点事件 hash 获取事件信息 参数 eventHash : string - 事件 hash 返回值 string - 事件信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getGlobalNodeEventByHash\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"]}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": \"\" } thanos_getGlobalNodeEventReceiptByHash 描述 通过全局节点事件hash获取事件回执 参数 eventHash: string - 事件 hash 返回值 string - 事件回执信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getGlobalNodeEventReceiptByHash\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"]}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": \"\" } thanos_getGlobalNodeEventByHashByChain 描述 通过交易 hash 批量获取交易信息 参数 transactionHash : string - 交易 hash 返回值 string - 交易信息 示例 // Request curl http://127.0.0.1:8080/rpc -X POST -d '{\"jsonrpc\":\"2.0\",\"method\":\"thanos_getGlobalNodeEventByHashByChain\",\"params\":[\"1f4470f412c41f8df44397fbe576ecd1cd557a7b15af2973c66cc4f7caa825fd\"],\"id\":1}' --header \"Content-Type: application/json\" | jq // Result { \"jsonrpc\": \"2.0\", \"id\": 1, //交易回执 \"result\": \"\" } Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/overview.html":{"url":"architecture/overview.html","title":"整体架构","keywords":"","body":"整体架构 概述 天玄区块链引擎使用模块化方式进行设计，方便对各个模块进行插拔和兼容。整体架构自下而上，天玄划分成基础层、核心层和网关层。 图1. 整体架构 基础层：提供天玄引擎基础的存储、P2P 网络、加密等模块和算法库。 核心层：实现区块链的核心功能和逻辑，分为两部分 区块链核心层，提供区块链特征的数据结构、交易执行引擎和账户存储驱动 互联核心层：实现区块链的基础 P2P 网络通信、共识机制和区块同步机制 网关层：面向区块链用户，提供交互的 RPC 接口、SDK 和控制台 核心模块 共识算法 天玄实现了可大规模扩展的 HotStuff 算法，并对其进行异步化改进升级，实现了更高性能的吞吐量和处理速度。在单链架构中，天玄将执行和共识过程分离，实现流水线共识、执行的异步化，进一步突破了单链的性能瓶颈。 P2P网络 天玄实现了 Gossip 协议，提供了高效、通用、安全以及节点发现的网络通信基础功能，支持区块链消息的 RPC 调用，单播和全局广播。 加密机制 天玄充分支持国产密码学算法，基于国产密码学标准，主要包括国密 TLSv1.1 协议、SM2 签名算法、SM3 消息摘要算法、SM4 加密算法、国密双证书模式、国密 Solidity 编译器。 执行引擎 天玄的可插拔执行模块目前支持 EVM 、JVM 两种执行引擎。并且针对串行效率问题构建交易执行依赖的 DAG 图，实现了线性序等价的并行执行。 存储模型 天玄针对联盟链场景，对存储模型进行了优化，去除了 MPT 树的索引结构，减少了在执行是对 MPT 树的检索。底层使用 LevelDB 作为持久化存储引擎，以支持海量数据。 身份认证 天玄采取集中式认证体系。为联盟链构建了三级的 CA 准入机制：【链证书 → 机构证书 → 节点证书】，分别对三个级别的组织、机构的加入和退出提供验证功能。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/tx-process.html":{"url":"architecture/tx-process.html","title":"天玄链交易流程","keywords":"","body":"天玄链交易流程 概述 在天玄中，智能合约是一段完整的业务代码，其中定义了对区块链数据状态读写的规则。而交易则是用户发起对智能合约程序的调用，实现对数据状态的变更媒介，其记录了区块链中数据状态发生变化的一切。交易的执行过程反映了用户在区块链上的活动，也是区块链系统的主要工作。 天玄区块链的交易流程主要分为四个步骤： 交易发起 交易共识 交易执行 状态变更持久化 图1. 交易流程 交易流程 1. 交易发起 当用户与应用客户端交互式，发生了区块链状态变更的操作，客户端需要通过天玄 SDK 构造一笔带用户签名的有效交易，以在区块链中执行这些状态变更。该笔交易包含： 交易发起地址：代表用户发起交易的地址（通常指公钥地址）。 交易的主要内容：待执行的智能合约代码（执行状态变更的主要内容）。 交易接收地址：通常指交互的智能合约地址。在联盟链中，交易分为两类，其一是部署合约交易；其二是合约调用交易。前者不指定地址，后者指定已部署的合约地址。 交易签名：使用的代表用户身份的地址产生的签名，以便天玄对交易进行验证，目的是防止伪造交易。 其他交易校验数据：具体可参见交易数据说明文档。 当客户端完成交易封装，则选择一个 RPC 节点，将交易发送至 RPC 节点。 2. 交易共识 当 RPC 节点接收到交易时，先进入交易池进行交易的预处理，再进行具体的共识排序、出块。具体如下： Gateway交易池处理 Gateway 之前需要对交易交易进行去重、签名验证。前者目的是在交易池的广播过程中去除重复的交易，减少广播重复交易的带宽消耗和计算消耗。后者的目的是验证交易签名的有效性。若不合法或者重复交易产生，将会被直接丢弃，不进入交易池。若合法则会通过 P2P 网络对交易进行广播，让交易尽可能到达所有节点。 共识处理 当交易被缓存到 Gateway 中时，共识模块会定时从交易池中拉去一定数量的交易进行排序（如按照 FIFO 原则排序）。按照区块数据说明文档，将该批次的交易进行封装，再由共识协议对区块进行共识。在联盟链中，共识协议仅承担排序的作用，目的是通过两阶段或者三阶段的广播让全网达成某个高度 h 的区块为 b 的共识，即 \\ 在每个节点的试图上必须一致。 3. 交易执行 在节点对区块完成共识后，按照共识顺序，将被执行引擎按照区块为单位进行交易的批次执行。 通常，区块链系统的运行被抽象为状态机，按照基于相同的初始状态开始，执行相同顺序的状态读写日志（即，交易），最终会到达相同的状态原则，一般会采用串行执行模型保证区块链状态的一致。在天玄中，交易执行采用了并行执行引擎。因此，通过开发者指定的依赖构造交易的依赖图，即 DAG 图，再根据 DAG 节点依赖关系对交易进行并行执行。 为保证并行执行的正确性，防止任何外部的行为导致的状态不一致，执行的过程存在两条路径： 1）快速路径，基于开发者指定的交易依赖构建 DAG 图，并执行成功。 2）串行慢速路径，若并行执行冲突，说明 DAG 构造存在问题，在当前区块回退到串行执行，保证执行后状态的一致性。 4. 状态变更持久化 在执行完成后，持久化内容分为两部分： 状态持久化 区块等交易执行回执持久化 同时，通知交易池剔除已经执行完成的交易。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/data-structure-and-encoding.html":{"url":"architecture/data-structure-and-encoding.html","title":"数据结构&编码","keywords":"","body":"数据结构&编码 区块链中，交易、收据、区块是三种重要的数据结构，是外界与区块链系统沟通的一种数据格式。 而天玄中，对以太坊原有的数据格式上新增了天玄必备的数据字段。如下： 交易数据（EthTransaction） 名称 类型 描述 RLP编码索引 publicKey bytes20 交易发起公钥 0 nonce u256 nonce值，标识当前交易执行的唯一性 1 futureEventNumber u256 系统查重使用 2 gasPrice u256 gas价格，天玄中暂未启用 3 gasLimit u256 gas限制，当前交易执行的gas消耗上限，天玄中暂无启用 4 receiveAddress bytes20 调用地址，交易调用的接收地址 5 value u256 当前交易的转账数额，天玄中暂未启用 6 data vector 调用内容，若receiveAddress=0x0，则为合约代码；否则为合约方法的函数签名 7 executeStates set 读写状态，当前交易涉及读、写的状态集合 8 signature vector 交易发起者签名 9 区块数据（Block） 名称 类型 描述 RLP编码索引 eventId bytes32 当前区块内容哈希，构建链式数据 0 preEventId bytes32 上一个区块内容哈希，构建链式数据 1 coinBase btyes0 矿工地址，天玄中暂未启用 2 stateRoot bytes0 状态跟，天玄中暂未启用 3 receiptsRoot bytes0 收据根，天玄中暂未启用 4 epoch u256 世代号，标记当前验证者集合所处时间单位 5 number u256 区块号，标记当前区块的高度 6 timestamp u256 时间错，标记当前区块的出块时间 7 globalEvents vector 全局事件，当前区块内包含的系统更新事件 8 receipts vector 交易收据，当前区块内包含交易的所有执行后收据 9：receipts size10：receipts[0]11：receipts[1]... 全局系统事件数据（globalEvent） 名称 类型 描述 RLP编码索引 publicKey vector 全局交易发起者公钥 0 nonce u256 nonce值，标识当前交易执行的唯一性 1 futureEventNumber u256 系统查重使用 2 commandCode byte 系统事件指令 3 data vector 调用内容，系统事件携带参数 4 signature vector 交易发起者签名 5 交易收据数据（EthTransactionReceipt） 名称 类型 描述 RLP编码索引 logInfoList vector event事件列表 0 ethTransaction EthTransaction 交易内容，产生收据的交易内容 1 gasUsed u256 gas消耗 2 executionResult vector 执行结果，当前交易的执行结果 3 error string 错误日志，标记当前交易执行错误原因 4 合约事件数据（LogInfo） 名称 类型 描述 RLP编码索引 address btyes20 合约地址 0 topics vector 事件主题 1 data vector 事件内容 2 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/":{"url":"architecture/core-modules/","title":"核心模块","keywords":"","body":"核心模块 本章节会介绍天玄链核心模块的设计方案： 共识算法 P2P网络 交易并行 存储 流水线执行 CA机制 网关 虚拟机 密码 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/consensus.html":{"url":"architecture/core-modules/consensus.html","title":"共识算法","keywords":"","body":"共识算法 概述 共识协议最早被使用在分布式容错系统当中，保证系统整体对外表现状态的一致性和活性。而区块链可以理解为一种拜占庭容错的分布式系统，区块链节点通过共识协议对输入的状态读写指令顺序达成一致，保证分布式系统执行指令顺序一致性，实现最终状态的一致性。其中，较为经典的共识算法簇 BFT ，其思想基本已经作为区块链的共识算法的主流，被广泛应用在公链或联盟链当中。 在天玄架构中，同样使用 BFT 算法簇之一的 HotStuff 作为其中共识模块的实现基础。相比较与经典的 PBFT 协议，HotStuff 算法具备低消息复杂度，视图切换和常规共识流程的统一性。在 HotStuff 基础之上，天玄结合执行和共识流程对其进行了异步化改造，进一步提升了整体架构的性能表现。 详细设计 基础模型 考虑在 4 个节点的系统当中，系统以连续的 Round 向前推进运行。每个 Round 里面存在一个主节点负责提供发起提案，其他节点负责投票。投票的结果将会被发送给当前 Round 的主节点，投票及结果由主节点收集后生成一个投票证明（QC：QuorumCert），并发送给其他节点。如此往复，每个 Round 内对同一个提案投票三次，得到三个投票证明，则表明当前的提案已经在全网达成共识，一定会被每个诚实的节点提交。 具体，三轮投票的原则，第一轮目的是确认 \"提案消息\" 被接收。第二轮目的是确认全网都知道了 \"提案消息\" 被接收。第三轮目的是防止主节点失效后更换主节点的状态同步消息复杂度（即视图切换和常规共识流程的统一性），原理可见原始论文。 在上述的模型中，由于每个提案共识完成需要经历三轮投票。于是产生了，工程实现上的流水线优化流程。通过链式结构合并相同提案投票过程到不同提案投票过程中，如下： 图1. HotStuff Chain 在天玄实现中，E 所代表的是共识事件 Event 消息，由一系列交易集合组成，每一个事件都有一个 Round 轮次，该轮次是单独递增 1 。QC 则是节点收消息后，投票内签名的集合或者生成的聚合签名，用来表示当前消息经过一定数量（BFT 系统当中，通常为系统节点数量的 2/3）的节点确认。流水线共识过程中，每次共识发起时，都会选择将 Round 轮次最大的 QC 包含在 E 消息内，来进行下一轮次的共识。当有某个 E 经过连续三轮正常共识的共识后，如上图中 Round(E1) + 2 == Round(E2) + 1 == Round(E3) 时，则全网可以对 E1 进行确认，即将状态变更持久化。 天玄共识流程 常规流程 图2. 共识流程 在核心的正常流程处理中，主要通过： Round：事件处理 ProcessProposalMsg：提案消息处理 ProcessVoteMsg：投票消息处理 以上三个流程来实现共识 Round事件处理 每个节点会记录当前本地的 Round，当 QC 创建成功时，会进行 Round 推进，推进到下一个 Round ，来触发下一轮的 Event 提案。 过程中，通过当前 Round 数值来确定系统产生提案的节点（即 Leader 节点，通过 Round % 节点数量 来确定 ）。随后 Leader 节点从交易池中拉取交易集合，将其打包成 Event 。同时，从 HotStuff chain 中获取 Round 值最大的 QC 作为 Parent Event ，然后向全网节点广播提案消息。 ProcessProposalMsg 当节点收到提案消息时，会通过该流程处理。其核心逻辑为，消息格式正确性校验，包括提案消息 Leader 签名、Round 计算、QC 验证等。消息校验通过后，节点使用 QC 推进本地的 Round ，即执行 Round + 1 。（节点使用 QC 推进 Round，所有节点适用）。 通过 QC 判断是否存在 Decide 阶段的 E (Event) ，如果有，则执行处于 Decide 阶段及其所有先驱节点进行共识提交（即持久化），并异步通知共识处理流程。 最后，在天玄中，还需要针对节点事件进行处理，当前是否存在节点加入、退出共识网络。 处理完成，将处理结果打包成投票消息，发送给 Round + 1 的新节点。 processVoteMsg 当进入到 Round + 1 时，新的 Leader 会收到来自 节点收集 来自 轮次为 Round 的节点投票消息。同样，对该消息进行一系列校验等，当收集达到 2/3 以上的投票消息时，则可以为上一个 Round 内的 E 生成对应的 QC ，并使用此 QC 推进到下一个 Round 。 异常流程 图3. 共识状态树 不同于 PBFT ，HotStuff 将视图切换流程和正常流程进行合并，即不再有单独的视图切换流程，从而降低了视图切换 (这里为 Round 切换) 的复杂度。因此，在 HotStuff 遭遇主节点不响应无法推进共识的情况下，进行 Round 切换时，系统中的某个节点也无需再对该 Round 切换进行共识，它直接切换到新视图并通知新的主节点。HotStuff 把确认 Round 切换这一消息的行为放进了正常流程中。 核心实现还是通过 Round 事件处理，在每一次成功推进 Round 时，都会为当前 Round 设置一个定时器。该定时器被设置一个超时时间，若再该时间段内，节点没有接收到任何有效消息（包括提案、投票消息) 。则认为当前系统失活，则进行超时处理 (本质上部分同步类的 BFT 是 Leader-based 模型，需要主节点进行提案驱动共识，当网络超时时，唯一的解决办法就是尝试更换主节点，当更换主节点成功，则恢复活性，也即在 GST 后保证活性） ProcessLocalTimeout，超时处理流程 若当前 Round 超时，则针对当前 Round 序号进行签名，生成超时投票消息，并广播超时投票消息。若节点收到投票消息，则处理投票消息内签名，与常规共识处理投票流程相似，当收集达到 2/3 以上的投票消息时，生成对应的 TC（TimeoutCert ，表示当前网络对网络超时达成共识）。 节点收到 TC 时，直接进行 Round 的推进。意味着，推进 Round 的方式有两种： QC 推进 Round + 1 TC 推进 Round + 1 推进 Round 后，新 Round 内的主节点则继续进行新的 Event 打包并发送提案消息。 因此，在实际的 HotStuff Chain 中，它是一个树状的链式结构。如图 3 所示，如 E2 在指定时间内，没有共识完成。因此 Round 推进到 Round + 1 ，继续共识 E3 。同样，在指定时间内，也没有共识成功，则继续推进到 Round + 2 ，而 E4 处理成功了，则按照正常的链式处理。当处理到 QC5 时，其前驱节点 E1 满足存在三个连续的 QC ，则 E1 及其所有前驱也会进入 Decide 流程。 链式同步 从上面的流程中，我们知道，在 HotStuff 共识流程中，需要通过 HotStuff Chain 中，系统的 Round 号由当前最大的 QC 或 TC 来决定 ，新的提案 Event 的前驱 Event 。因此，在正常情况下，非 Leader 节点只会落后 Leader 节点一个最新的 QuorumCert 。在 Leader 节点将 Round + 1 的提案广播给全网节点时，会在提案消息 Event 内附带当前 Round 最大的 QC ，基于此构建链式的共识数据结构，而当非 Leader 再收到提案消息时，经过校验后，既可扩展自己的最长链。 然而，在一些特殊情况下，会存在某些节点会落后 Leader 节点相当轮次的情况。依然会按照最长链的拓展原则进行同步处理，推进本地节点的 Round。 当当前节点追赶上共识的 Round 后，便可正常加入网络参与共识。 共识存储 为了从工程学上百分百保证 HotStuff 不会因为各种原因（例如宕机）而导致分叉出现。因此，节点在共识流程中，会将验证通过的 Event 或者 QuorumCert 都落盘。在发起投票前，也会将 Vote 的请求落盘到共识存储中。当系统重启时，会将这些落盘的 Event 、QuorumCert 以及 Vote 从数据库中加载出来，构造当前 HotStuff Chain 的最新状态，然后根据最新的状态进入共识流程。当某个 Event 完成 Decide 流程后，会执行清除逻辑。 如图 3 的情况下，E3 被提交，即执行 Decide 流程。在流程执行完成后，会将图中的 E3 的所有前置节点从共识存储中删除。 共识切换 这里的 Epoch 指的是在相同的 Validator Set 下，执行共识集群。Epoch 从 0 开始，当集群接收到节点注册/删除的共识事件时，并且事件共识成功，则会发生 Epoch 切换。当 Epoch 发生变换时，会将当前还没有进入 Decide 阶段的事件重新发起共识。 异步化 目前，基于 BFT 算法簇所实现的公链项目中，共识的过程既包括交易的顺序，也包括当前区块执行后的状态。意味着，共识开始前需要先执行区块中的所有的交易。那么在单链架构的情况下，如果需要将其 TPS 提升到万、十万、二十万时，会出现比较多的严重问题。BFT 协议为了保证活性，需要定时器去检测网络是否出现有效消息，否则就认为主节点失活。其一轮共识超时时间基本都是在 10 秒以内。因此，在每一轮共识打包的交易数量中，需要动态调整。而共识过程中，如果需要额外执行交易，并且其耗时也是不可精确预估，尤其是共识大批量交易的情况。 因此，天玄区块链引入了异步化的概念。核心在于上述 Hotstuff 共识中，只共识以 Event 为组织单位的交易序，即在 Hotstuff 共识流程中，不处理任何 Event 中的交易。待 Event 被共识成功后（即确序），再将确序的 Event 交由通用流水线执行器来执行。执行完成后，对产生的执行后状态进行共识。 注：此处的共识每个正确的节点均有相同的输入，即执行后区块哈希，应使用可靠广播协议+签名验证即可。应注意 agreement 协议和 broadcast 协议的区别，见：https://decentralizedthoughts.github.io/2019-06-27-defining-consensus/。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/p2p-network.html":{"url":"architecture/core-modules/p2p-network.html","title":"P2P网络","keywords":"","body":"P2P网络 概述 天玄 P2P 模块提供高效、通用、安全以及节点发现的网络通信基础功能，支持区块链消息的 RPC 调用，单播、片内广播和全局广播。主要功能： 区块链节点标识 通过区块链节点标识唯一标识一个区块链节点 (nodeId) ，在区块链网络上通过区块链节点标识对区块链节点进行唯一区分确认。 管理网络连接 维持区块链网络上区块链节点间的 TCP 长连接，自动断开异常连接，自动发起重连。 消息收发 在区块链网络的区块链节点间，进行消息的 RPC 调用，单播、片内广播和全局广播。 详细设计 区块链节点标识 区块链节点标识由椭圆曲线算法的公钥生成，每个区块链节点必须有唯一的椭圆曲线密钥对，区块链节点标识在区块链网络中唯一标识一个区块链节点。 通常情况下，一个节点要加入区块链网络，至少要准备三个文件： node.key：节点密钥，EC/ED/SM 等格式 node.crt：节点证书，由 CA 颁发 ca.crt：CA 证书，CA 机构提供 管理网络连接 区块链节点间，会自动发起和维持 TCP 长连接，在系统故障、网络异常时，主动发起重连，区块链节点间建立连接时，会使用 CA 证书进行认证。 连接建立流程 建立 TLS 链接既是为了验证节点身份的合法性，又为后续新节点发送入网请求做准备。建立 TLS 链接的步骤如下： 节点利用密钥文件 node.key 和 chain.crt 初始化 SSLContext 。 节点发送 TLS 链接请求给共识节点，请求建立连接。 当双向身份认证通过后，TLS 链接建立成功，新节点与共识节点可以进行通信。 消息收发 区块链节点间消息支持单播、组播和广播 RPC 调用：会向单一区块链节点发送消息，并同步等待响应结果。 单播：单个区块链节点向单个区块链节点发送消息，通过区块链节点 ID 区分。 片内广播：单个区块链节点向同一分片内的区块链节点发送消息。 全局广播：单个区块链节点向所有区块链节点发送消息。 单播流程 区块链节点 A 区块链节点 B 根据节点 ID ，筛选在线节点发送消息消息回包区块链节点 A 区块链节点 B 。 片内广播 区块链节点 A 会依据自身所在分片，获取所有相同分片的 Peer 节点，逐个发起单播流程。 全局广播 区块链节点 A 获取所有的区块链节点，阻隔发起单播流程。 RPC调用 区块链节点 A 区块链节点B根据节点 ID ，会发起一个有 RPC 标识的消息单播发送，节点 B 收到该 RPC 消息后，会依据具体的消息，将处理结果返回节点 A 。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/tx-parallelization.html":{"url":"architecture/core-modules/tx-parallelization.html","title":"交易并行","keywords":"","body":"交易并行 概述 早期的区块链系统，其执行引擎都是一个串行执行模型，这种模型虽能保证执行的正确性，但却是区块链性能的一个核心瓶颈之一。天玄中，通过识别交易中的状态依赖，构建交易依赖图来对执行引擎进行并行化，从而提升交易执行速度，解决该瓶颈。 详细设计 通用 DAG 分析器 一个无环的有向图称做有向无环图（Directed Acyclic Graph），简称 DAG 图。在一批交易中，可以通过一定方法识别出每笔交易需要占用的互斥资源，再根据交易在 Event 中的顺序及互斥资源的占用关系构造出一个交易依赖 DAG 图，如下图所示，凡是同一 Level (无被依赖的前序任务) 的交易均可以并行执行。如下图所示，基于左图的原始交易列表的顺序进行拓扑排序后，可以得到下图的交易 DAG 。 图1. 交易DAG 核心结构： 图2. 核心结构 LevelDAG：会根据输入的可执行交易列表 Txs ，最大可并行执行层级（maxParallelLevel）以及最大层级深度（maxLevelDeep），生成可并行执行 ExecuteRoot（Level-0）。 ExecuteRoot：可并行执行根节点，该数据结构主要包含可并行执行的节点 (List\\) 列表。换言之，并行执行器会并行执行 ExecuteRoot 所对应的可执行节点 (List\\) 集合。然后在依据当前 Level 的执行状况，主动触发下一 Level 层级所对应的可执行节点(List\\)列表。 Level：当前层级数据结构抽象，主要用于控制最大可并行执行层级（maxParallelLevel），该参数可以这样理解，如当 maxParallelLevel 为 1L 时，即表明 当前执行 Level 必须要等待 Level 1 的所有执行可执行节点执行完成，才可以继续执行。 ExecuteState：执行状态抽象，对应 DAG 中的状态。 通用 DAG 执行引擎 该通用执行引擎的设计目的就是根据 2.1 中通用 DAG 分析器所生成的 ExecuteRoot ，以固定的线程任务，最大并行度地执行交易，根据 LevelDAG 生成的 ExecuteRoot ，并获取 ExecuteRoot 可并行执行节点列表 parallelExecuteNodes，然后遍历该列表节点（ExecuteNode），将执行任务提交给线程池。 线程池会对 ExecuteNode 执行逻辑，具体流程如下： 先判断节点所在的 Level 的前一个 Level 是否执行完成，如果没有执行完成则加入待重试队列，交由待重试 reactor 线程后续轮循执行。否则，说明当前节点可以执行，则执行相应的交易方法（即可以时以太坊的智能合约交易，也可以是 Java 的智能合约）。 前置依赖节点执行完成，执行当前 Level 节点。 当前 Level 每个节点执行完毕。将当前 ExecuteNode 所对应 Level 的待完成执行数减 1（该标志为步骤 1）中判定前置节点是否执行完成）. 遍历当前 ExecuteNode 所对应的被依赖节点，并对被依赖节点执行移除前置依赖。若此时被依赖节点依赖关系节点数量为 0 ，则对该节点执行步骤 1）。如此递归，直到所有的节点被执行完成。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/storage.html":{"url":"architecture/core-modules/storage.html","title":"存储","keywords":"","body":"存储 概述 在传统公链架构中，核心的存储模型架构还是以 MPT（默克尔压缩前缀树）的方式组织，目的是方便对状态提供存在性证明。使用 MPT 树能够最大程度上提供数据的存在性证明的情况下，减少树更新的计算次数。但对于联盟链来说，使用 MPT 树是一种性能的降低。在基于 EVM 的账户模型数据以及合约代码中数据的存取 ，其底层就是对 MPT 的 CRUD 操作。因此，树节点的读取可能会读取多次磁盘（根据树高以及节点的大小来决定读取次数），而一个节点的变更可能会引起 MPT 多次的裂变。 随着合约代码的存储数据越大，会导致 EVM 执行速度线性下降(生产环境中，以出现线性下降的情况)。而天玄中，通过去 MPT 的存储结构来解决随着状态数据的增加而导致 EVM 执行速度线性下降的问题。 去MPT存储 MPT 使用对比 优点 性能相比于原来的方案会有所提升，提升率需要测试。 使链的共识性能保持稳定 (前提是依赖的 Level db 底层性能稳定，经过许多产品大量测试，表现稳定。详细的性能测试指标参考：http://www.lmdb.tech/bench/microbench/benchmark.html#:~:text=In%20order%20to%20test%20Leveldb's%20performance,%20we%20benchmark%20it%20against 。 使用去 MPT 方案后，状态变量的 读取可以加上缓存层，加快状态变量读取速度，从而提升 EVM 执行速度。 缺点 去 MPT 方案目前 只是能用于联盟链，无法使用于公链中。 目前只适用于强一致性共识算法。 目前只存储最新状态值，无法访问特定历史状态； 以太坊 MPT 树状态检索 在以太坊中，区块链全局状态被存储在 MPT 树中，这些全局状态通常指账户状态。而智能合约中的数据状态则是存在于智能合约账户的 MPT 子树中，即以账户维度管理合约数据。如下： 图1. 以太坊MPT存储 所有的状态两边都被抽象为 k-v 键值对 \\ 。其中，storage key 为 MPT 状态树中的唯一索引（压缩前缀树的索引方式），计算方式与 EVM 的存储布局有关。EVM 以每 32 个字节为单位组织存储，被称为 Slot ，每个 MPT 树的叶子节点存储的就是该 Slot 的值，计算方式为：storage key = keccak256(bytes32(key) + bytes32(position) 。当需要向 MPT 查询时需要自顶向下依次由 storage key 的字符指定的 MPT 路径，而在实际的实现中过程如下： 图2. 存储处理流程 SSTORE（写入）： 将智能合约账户内的状态变量写入值写入一级缓存 Account cache 。 遍历 Account cache 中的数据，写入二级缓存 MPT cache 中。过程中，自底向上更新 MPT 树的叶子节点、中间节点，直至产生新的 MPT root 。 共识完成，提交时在 commit 流程中将 MPT cache 中每个节点落盘到 Level db 中持久化。 SLOAD（读取）： 根据智能合约地址读取，读取合约账户的状态子树。 根据 storage key 读取向子树检索到存储 value 的叶子节点。 其中，依次先向缓存、db 读取。 天玄去MPT架构 由于每次读写状态都需要对前缀树进行检索，严重影响联盟链场景下的执行效率。天玄直接使用 HashMap 作为替代方案，每个 \\ 直接存储到 HashMap 中，不通过 MPT 树检索。另外，为了区分不用合约账户的数据状态，确保数据状态的全局唯一性，storage key 的计算方式变为：new storage key = sha3(account address+ storage key) 。 天玄架构中，去 MPT 对整个架构的影响体现在两个部分。 共识执行部分，发生对状态的读写工作。 状态的持久化工作。 图3. 天玄处理流程 EVM 指令执行 SSTORE：直接使用对哈希 Map 的 put(new storage key, value) ，此处也不再需要更新数据状态所属合约的 MPT 子树、账户状态 MPT 树。 SLOAD：直接向缓存或 db 读取 get(new storage key, value) ，此处减少了读取账户状态 MPT 树、数据状态的子树。 STATE COMMIT 实现 区块提交直接提交哈希 Map 中的数据，进行持久化即可，减少了存储 MPT 中间节点的开销。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/execution-pipeline.html":{"url":"architecture/core-modules/execution-pipeline.html","title":"流水线执行","keywords":"","body":"流水线执行 概述 区块链中，共识外的另一大性能瓶颈就是执行。主要原因是由于执行过程涉及到状态、区块链数据的持久化过程，该过程极度影响性能。为了将天玄的性能推到极致，在执行阶段针对执行、提交、持久化瓶颈进行流水线并行处理。 天玄中，重新定义了区块交易执行过程，分为了三个阶段。 Execute 执行：见并行执行小节。 Flush 刷盘：执行状态缓存刷盘到Level db缓存。 Persist 持久化：区块执行后状态持久化。 由此，一个区块的第一阶段(交易执行)，可以与上一个 block 的第二阶段以及第三阶段并行执行。 图1. 执行流水线 流水线执行器 异步执行 天玄中的三个阶段，执行、刷盘阶段都在本地完成，而第三阶段持久化则需要通过共识完成，全网执行状态的确认再持久化。启用两个线程的流水线处理过程如下： AsyncExecutor 在启动时，将启动两个线程来流水线处理所有定序的区块，分别为 mainExecutor 以及 subExecutor 。 mainExecutor 先获取当前需要待执行的已定序的共识负载（payload）并转为区块来执行，并等待唤醒信号，该信号来自于上一个区块的刷盘阶段执行完成。 当上一个区块的刷盘阶段完成后，会唤醒当前区块，该区块会进行执行阶段。在执行阶段执行完成后，会进入刷盘阶段。同样在进入刷盘阶段前，会等待一个唤醒信号，该信号则是上一个区块的持久化阶段完成。 当上一个区块的持久化阶段执行完成后，会继续唤醒当前区块，该区块会进行刷盘阶段。当刷盘阶段完成后，一方面通过异步队列，将该区块交由执行后状态的一阶段 BFT 共识，若该区块执行后状态共识成功，则会执行当前区块的持久化阶段，并主动唤醒下一个区块的持久化等待。另一方面，如果当前区块并非最新区块，即还存在下一个区块，则继续将该区块交由 subExecutor 执行上述逻辑，如此循环。如下： 图2. 并行处理流程 执行后状态共识、持久化 其中 \"异步 Persist\" 过程，则需要对区块执行后状态进行共识，从而到达完整的提交流程处理。具体实现流程见下： 执行器按共识顺序执行 Event 交易，执行后生成区块并通知 GlobalStateVerifier 执行执行后状态全网验证。 GlobalStateVerifier 获取执行后待验证区块，委托 GlobalStateCoordinator 执行区块状态验证，并同步阻塞，直到当前区块验证、提交成功。 GlobalStateCoordinator 通过 P2P 网络将区块签名哈希及其签名广播全网节点。 GlobalStateCoordinator 收到同一区块状态的 2/3 节点的响应时，即认为当前区块执行后状态达成共识，否则则对区块进行回滚。根据结果通知 GlobalStateVerifier 执行。 GlobalStateVerifier 根据 GlobalStateCoordinator 结果执行相应的逻辑，提交或者回滚。 注：GlobalStateCoordinator 本质上执行的是一个异步网络协议，可靠广播，不需要考虑超时处理情况，仅需要重试即可 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/certificate-authority.html":{"url":"architecture/core-modules/certificate-authority.html","title":"CA机制","keywords":"","body":"CA机制 概述 天玄作为联盟链，需要一套完整的联盟准入机制，即加入通信网络并参与共识的节点必须是经过验证的联盟成员。因此，天玄使用了一套基于 CA 体系构建的联盟准入机制，该机制理论上支持任意多级的证书结构，保证了良好的扩展性。根据现有业务场景，目前采用三层证书体系：【链证书 → 机构证书 → 节点证书】。 其中，链证书 作为根证书，承担信任根的角色，由链管理员生成。一条联盟链唯一对应一个链证书，联盟链的所有节点都共享链证书，用于验证彼此证书的合法性。机构证书 由机构管理者持有，用于给隶属于该机构的联盟节点颁发证书。通过层级设计，减少链私钥的使用，提高 CA 体系的安全性。节点证书 由节点管理者持有，用于证明该节点公钥的合法性，在与其他节点建立安全通信和对消息进行签名验签的过程中必不可少。 在三层证书体系的基础上 一个新节点能够可控、安全的从生成密钥和证书，到与共识节点建立安全通信，再到经过共识加入共识网络、参与共识。 详细设计 三层证书体系 图1. 三级证书体系 三层模型中 链证书 作为根证书，承担信任根的角色，由链管理员生成。链管理员维护着链私钥，实质上承担着 Root CA 的角色，负责给二级 CA（即联盟中的各机构）颁发证书。 机构证书 由机构管理者持有，用于给隶属于该机构的联盟节点颁发证书。机构管理者维护机构证书的私钥，实质上承担着二级 CA 的角色，负责给整个 CA 体系中的用户（即联盟中的各节点）颁发证书。通过二级 CA 分担根 CA 的职责，减少链私钥的使用，提高整个证书体系的安全性。同时，机构私钥的泄漏只影响该机构下属节点，对其他机构及节点没有影响。 节点证书由节点管理者持有，是节点身份的凭证，用于证明该节点公钥的合法性。节点证书 在与其他持有合法证书的节点建立 TLS 连接时必不可少。 当两个节点建立 TLS 连接时，需要校验双方证书的合法性，这一步主要由 SSL 握手协议完成。本质上就是以链证书作为信任根，验证【链证书 → 机构证书 → 节点证书】这条证书链。验证过程需要从节点证书开始，链式向上验证证书，直到完成根证书的验证，过程如下： 图2. TLS连接过程 天玄 CA 机制 在三级证书体系的基础上，进一步构建 CA 机制的整体架构如下： 图3. 天玄CA机制 考虑一个新节点想要加入联盟网络，需要： 生成节点公私钥及证书。其中，节点证书需由该节点所属机构签发。 新节点会主动与网络中已有节点建立 TLS 连接，建立连接的过程中需要提供节点证书（实际是证书链）用于建立双向认证。 通信连接建立后，新节点会主动向共识节点发送 Web3 请求，包含了节点自身的身份和公钥信息。 共识节点针对新节点的加入请求进行共识，共识达成后，将新节点的身份和公钥信息上链，共识节点列表完成更新。 新节点成功加入共识网络，可参与后续交易的共识。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/gateway.html":{"url":"architecture/core-modules/gateway.html","title":"网关","keywords":"","body":"网关 概述 在天玄中，网关的主要任务是负责接收外部交易并缓存到交易池、使用 P2P 协议对加以进行广播、推送交易池中的交易到节点中进行共识、执行。 通常，完整的以太坊节点交易池、P2P 、共识节点网络一体，尤其是在大量交易等待验签、广播的场景下，交易不能得到充分传播，联盟链性能很容易受到约束。而抽象出网关单独处理验签、广播、交易池的工作能够提高交易的吞吐量，释放共识性能。 详细设计 天玄网关可分为三个模块： JSON RPC 服务。 交易池服务。 交易广播服务。 图1. 网关架构 JSON RPC 天玄 JSON RPC 是一套基于 Jsonrpc4j 提供的 RPC 服务，其遵循 JSONRPC 2.0 标准，主要提供区块链数据查询和交互的功能，详细的接口定义参考 JSON-RPC API接口文档 交易池 天玄网关交易池是一个生成者和消费者模型，由 JSON RPC 服务接收消费者交易，由广播和推送服务消费交易。基本模型如下： 图2. 交易池 交易池的主要工作包含： 对输入的交易进行签名验证。 缓存有效交易并推送广播。 推送交易到共识节点。其中，推送服务是一个由 GRPC* 实现的一个高速透传发送，可以将推送队列中的消息快速推送到天玄共识节点。GRPC* 拥有压缩效率高，传输速率高等优点。 交易广播服务 广播服务本质上是一个 P2P 网络，它由树状构造节点连接，收到消息后广播到根节点，由根节点快速广播到子节点。模型如下： 图3. P2P N 叉树交易池 模型中，所有节点以 ID 表示，从小到大排序后，组成树状网络。非根节点收到消息后推送根节点，然后由父推送给子节点依次完成推送。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/vm.html":{"url":"architecture/core-modules/vm.html","title":"虚拟机","keywords":"","body":"虚拟机 概述 在区块链中，业务数据被抽象为系统状态的一部分，即区块链状态。而区块链状态修改的逻辑则被抽象成智能合约代码。用户通过发送区块链交易完成智能合约完成区块链状态的变更，其中以太坊虚拟机是负责执行区块链交易完成这一变更过程的执行器。当被共识过的一系列交易，被每个节点按照相同顺序执行后，区块链的状态也保证一致性。 EVM 虚拟机 EVM 虚拟机是一个图灵完备的栈式虚拟机，能够完成任意类型的计算工作，即任意代码逻辑可以被编写并在区块链上执行。 EVM 指令 EVM 指令指定义了在 EVM 虚拟机上的计算规则的操作码及其参数。和其他类型的编程语言一样，智能合约代码会被编译器编译成 EVM 可读的字节码，由 EVM 内部的解释器读取每个操作码指令并执行。 算数指令举例 一条 ADD 指令，在 EVM 中的代码实现如下。SP 是堆栈的指针，从栈顶第一和第二个位置 (SP[0] 、SP[1]) 拿出数据，进行加和后，写入结果堆栈 SPP 的顶端 SPP[0] 。 case ADD: { DataWord word1 = program.stack.pop(); DataWord word2 = program.stack.pop(); DataWord addResult = word1.add(word2); program.stackPush(addResult); program.step(); } 跳转指令举例 JUMP 指令，实现了二进制代码间的跳转。首先从堆栈顶端 SP[0] 取出待跳转的地址，验证一下是否越界，放到程序计数器 PC 中，下一个指令，将从 PC 指向的位置开始执行。 case JUMP: { DataWord pos = program.stack.pop(); int nextPC = program.verifyJumpDest(pos); program.setPC(nextPC); } 状态读取指令举例 SLOAD 可以查询状态数据。大致过程是，从堆栈顶端取出要访问的 key ，把 key 作为参数，然后调 program.storageLoad ，查询相应的 key 对应的 value 。之后将读到的 value 写到结果堆栈顶端。 case SLOAD: { DataWord key = program.stack.pop(); DataWord value = program.storageLoad(key); if (value == null || value.getData() == null) value = key.and(DataWord.ZERO); program.stackPush(value); program.step(); } 其他 完整指令请参考EVM虚拟机指令。 JVM 虚拟机 当前版本仅支持，系统内部事件的合约编写。 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"architecture/core-modules/crypto.html":{"url":"architecture/core-modules/crypto.html","title":"密码","keywords":"","body":"密码 概述 天玄充分支持国产密码学算法，基于国产密码学标准，实现了国密加解密、签名、验签、哈希算法、国密 SSL 通信协议，实现了对国家密码局认定的商用密码的完全支持。 国密版天玄将交易签名验签、P2P 网络连接、节点连接、数据落盘加密等底层模块的密码学算法均替换为国密算法，国密版天玄与标准版主要特性对比如下： ECDSA版天玄 EdDSA版天玄 国密版天玄 SSL链接 Openssl TLSv1.2协议 TLSv1.3协议 国密TLSv1.1协议 签名验证 ECDSA签名算法 Ed25519签名算法 SM2签名算法 消息摘要算法 SHA-256 SHA-3 SHA-256 SHA-3 SM3消息摘要算法 落盘加密算法 AES-256加密算法 AES-256加密算法 SM4加密算法 证书模式 OpenSSL证书模式 OpenSSL证书模式 国密双证书模式 合约编译器 以太坊solidity编译器 以太坊solidity编译器 国密solidity编译器 (注：国密算法 SM2 , SM3 , SM4 均基于国产密码学标准开发) 系统框架 系统整体框架如下图所示： 图1. 天玄密码框架 国密SSL 1.1 握手建立流程 国密版节点之间的认证选用国密 SSL 1.1 的 ECDHE_SM4_SM3 密码套件进行 SSL 链接的建立，差异如下表所示： | | OpenSSL | 国密SSL | | ------- | ------------- | ------------- | | 加密套件 | 采用ECDH、RSA、SHA-256、AES256等密码算法 | TLSv1.3协议 | | PRF算法 | SHA-256 | SM3 | | 密钥交换方式 | 传输椭圆曲线参数以及当前报文的签名 | 当前报文的签名和加密证书| | 证书模式 | OpenSSL证书模式 | 国密双证书模式，分别为加密证书和签名证书 | 数据结构差异 国密版与标准版天玄在数据结构上的差异如下： | 算法类型 | ECDSA版天玄 | EdDSA版天玄 | 国密版天玄 | | ------- | ------------- | ------------- | ------------- | | 签名 | ECDSA (公钥长度: 512 bits, 私钥长度: 256 bits) | Ed25519 (公钥长度：256bits 私钥长度：256bits) | SM2 (公钥长度：512 bits, 私钥长度：256 bits) | | 哈希 | SHA3 (哈希串长度: 256 bits) | SHA3 (哈希串长度: 256 bits) | SM3 (哈希串长度: 256 bits) | | 对称加解密 | AES (加密秘钥长度: 256 bits) | AES (加密秘钥长度: 256 bits) | SM4 (对称密钥长度: 128 bits) | | 交易长度 | 520bits（其中标识符8bits,签名长度512bits） | 520bits (其中标识符8bits,签名长度512bits) | 1024bits(128字节，其中公钥512bits,签名长度512bits) | Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 18:04:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"community/channel.html":{"url":"community/channel.html","title":"社群入口","keywords":"","body":"社群入口 关注公众号 Copyright © netease 2024 all right reserved，powered by Gitbook文档修订时间： 2024-09-14 17:05:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}